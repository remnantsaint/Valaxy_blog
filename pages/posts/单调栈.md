---
layout: post
title: 单调栈
date: 2025-09-08 12:14:38
updated: 2025-09-08
time_warning: true 
cover: 
top: 
tags: 
 - 单调栈
categories: 
 - 算法基础
 - 栈与队列
# author: @Remsait
---
  单调栈是一种维护栈内元素单调性的数据结构，通常用于解决”最近一个比当前数大/小“的问题

  核心想法是：利用栈保存若干候选位置，再用单调性快速剔除不可能的候选，从而让每个元素只”进出栈“一次，实现线性复杂度

  栈里存下标，不直接存值；每次入栈前，弹出所有”不符合单调“条件的下标，使剩余元素保持所需趋势  

  先清理（弹出无用），再读栈顶作为答案，最后如栈

  模板如下：
```c++
stack<int> st;
for (int i = 0; i < nums.size(); i++) {
    while (!st.empty() && 比较条件) {
        // 处理被弹出元素的答案
        int index = st.top();
        st.pop();
        // 答案处理...
    }
    // 处理当前元素的答案（如果需要）
    st.push(i);
}
```
## 739. 每日温度
[题目链接](https://leetcode.cn/problems/daily-temperatures/description/)  
题意：给一个整数数组表示每天的问题，返回一个数组 answer，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后，如果气温在这之后都不会升高，在该位置用 0 来代替  
思路：使用单调栈，遇到高温就把栈顶元素的 answer[i] 设置为高温，然后出栈，把温度小的全出了，原始数据都填 0   
代码如下：  
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> answer(temperatures.size());
        stack<int> st;
        for(int i = 0; i < temperatures.size(); i++){
            int x = temperatures[i];
            while(!st.empty() && x > temperatures[st.top()]){
                answer[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return answer;
    }
};
/*
自己直接写出来了，无敌
创建 vector 数组后，值默认为 0 ？
*/
```


## 42. 接雨水
[题目链接](https://leetcode.cn/problems/trapping-rain-water/)  
题意：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨后能接多少雨水  
思路：运用单调栈，
代码如下：  
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int answer = 0;
        stack<int> st;
        for(int i = 0; i < height.size(); i++){
            int x = height[i];
            while(!st.empty() && x > height[st.top()]){
                // 只要大于底部，就会出栈然后计算左右挡板，开始循环
                int bottom_idx = st.top();
                st.pop();
                // 每轮 while 计算一层 
                if(!st.empty()){
                    int left_idx = st.top(); // 左挡板
                    int right_idx = i; // 右挡板
                    int width = right_idx - left_idx - 1; // 宽度
                    int water_height = min(height[left_idx], height[right_idx]) - height[bottom_idx]; // 高度
                    answer += width * water_height; 
                }
                // while 运行后，会把所有小于 x 的都出栈，直到能形成挡板再计算
                // 计算过程中，必须左右挡板都大于底部高度，否则结果 + 0
            }
            st.push(i);
        }
        return answer;
    }
};
```



## 3676. 碗子数组的数目
[题目链接](https://leetcode.cn/problems/count-bowl-subarrays/description/)  
题意：  
给一个整数数组 nums，包含互不相同的元素  
nums 中的一个子数组 nums[l....r] 被称为碗，如果它满足：子数组的长度至少为 3 ，两端元素的最小值严格大于中间所有元素的最大值  
返回 nums 中碗子数组的数量  

思路：用单调栈，从头开始入栈，存下标，遇到大数，就把前面小于该数的都出栈，边出边判断是否大于 3 ；这时是左小右大，小的都出完后，判断一下左大右小  
代码如下：
```c++
class Solution {
public:
    long long bowlSubarrays(vector<int>& nums) {
        int ans = 0;
        stack<int> st;
        for(int i = 0; i < nums.size(); i++){
            int x = nums[i]; // 当前值
            while(!st.empty() && x > nums[st.top()]){ // 左小右大，把符合条件的左边小的都出栈
                if(i - st.top() > 1){ // 证明中间有比左边更小的，形成了碗
                    ans++;
                }
                st.pop();
            }
            if(!st.empty() && i - st.top() > 1){ // 左大右小
                ans++;
            }
            st.push(i);
        }
        return ans;
    }
};
/*

单调栈

数组元素互不相同
碗的长度至少为3，左右的最小值严格大于中间所有元素

对于每个右端点 r ，只需要找 nums[r] 左侧最近的大于等于 nums[r] 的数的下标 l，如果 l 存在且 i - l + 1 >= 3，那么找到一个合法
对于 nums[l] < nums[r] 的情况，同样用单调栈计算

对每个位置 i 作为右端点，找到所有可能的左端点
使用单调递减栈来维护候选的左端点：
栈中存储下标，对应的元素值单调递减
当遇到更大元素时，弹出较小元素并检查是否能形成碗

*/
```



