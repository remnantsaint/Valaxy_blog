---
layout: post
title: 找出字符串中第一个匹配项的下标
date: 2025-08-17 16:03:43
cover: 
top: 
tags: 
 - 字符串
categories: 
 - 算法基础
 - 字符串
# author: @Remsait
---
## 28. 找出字符串中第一个匹配项的下标
[题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)  
题意：  
给两个字符串 a 与 b ,，在 a 字符串中找出与 b 字符串的第一个匹配项的下标，如果找不到返回 -1  
思路：  
`KMP算法`经典题，下面来重新学一下 KMP  
### KMP作用
KMP住药应用在字符串匹配中  
思想是**当出现字符串不匹配时，可以知道一部分已经匹配的文本内容，利用这些信息避免从头再去匹配**  
所以需要用 next 数组记录已经匹配的文本内容  
### 什么是前缀表
next 数组就是前缀表  
其**作用是回退，记录了模式串与主串不匹配的时候，模式串应该从哪里开始重新匹配**  
也就是**记录下标 i 之前（包括 I）的字符串中，又多大长度的相同前后缀**  
### 最长公共前后缀
文章中字符串的前缀是指**不包含最后一个字符的所有以第一个字符开头的连续字串**  
后缀是指**不包含第一个字符的所有以最后一个字符结尾的连续字串**  
**前缀表要求的就是相同前后缀的长度**
比如字符串 a 的最长公共前后缀为 0 ， aa 为 1 ，aaa 为 2  
### 为什么用前缀表
例如模式串为 aabaaf ，主串为 aabaabaaf ，当模式串匹配到 f 时匹配失败，而匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了  
所以前缀表告诉我们当前位置匹配失败的话，应该跳到之前已经匹配过的地方  
### 如何计算前缀表
在下标从 0 开头的数组中，每个 i 位置的 next[i] 就等于以 i 这个位置结尾的前缀字符串的最长公共前后缀的长度。  
前缀表只在模式串中计算，比如 aabaaf ，其 next 数组就为 0 1 0 1 2 0  
匹配过程中，当字符不匹配的时候，模式串指针就应该移动到该字符前一个下标的前缀表所对应的下标的位置  
为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。  
next 数组既可以直接等于前缀表，也可以等于前缀表中的所有数值 -1，变为前缀表统一减一之后的next数组  
### 时间复杂度
KMP的时间复杂度为 O(n + m) ，其中 n 是文本串长度， m 是模式串长度  
而暴力解法的时间复杂度为 O(n * m)   
### 构造 next 数组
定义一个函数 getNext 来构建 next 数组，函数参数为指向 next 数组的指针和一个字符串，如下：
```c++
void getNext(int* next, const string& s){}
// 其中 int* next 与 int next[] 一致
```
构造 next 数组就是计算模式串 s 的前缀表的过程，主要有三步  
1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

首先是初始化，定义两个指针 i 和 j ，**j 指向前缀末尾位置， i 指向后缀末尾位置**  
i 始终是“新加的那个字符”，问它能不能延长前缀匹配。  
j 始终表示“当前最长前缀”的末尾位置。  
然后还要对 next 数组进行初始化赋值  
```c++
int j = -1;
next[0] = j;
```
这里写的是 next 数组初始为 -1 的版本  
**减 1 的优点是处理 j = 0 时的边界更容易，因为原版要跳转的话得访问 next[j - 1] ，如果 j = 0 的话会越界**  
next[i] 表示 i 之前（包括 i ）最长相等的前后缀长度  
<br>
然后是处理前后缀不相同的情况  
因为 j 初始化为 -1 ，那么就从 1 开始进行 s[i] 与 s[j+1] 的比较，所以遍历模式串 s 的循环下标要从 1 开始，代码如下：
```c++
for (int i = 1; i < s.size(); i++) {}
```
如果 s[i] 与 s[j + 1] 不同，也就是遇到前后缀末尾不相同的情况，就要向前回退  
因为 next[j] 记录着 j （包括 j ）之前的字串的相同前后缀长度  
那么s[i] 与 s[j + 1] 不相同，就要找 j +1 前一个元素在 next 数组里的值（next[j]）  
代码如下：  
```c++
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```

<br>

处理前后缀相同的情况  
如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动 i 和 j ，说明找到了相同的前后缀，同时还要将 j （前缀的长度）赋值给 next[i]，因为 next[i] 要记录相同前后缀的长度  
代码如下：
```c++
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```

<br>

整体代码如下：
```c++
void getNext(int* next, const string& s) {
    int j = -1;        // j 表示前缀末尾的指针，初始为 -1
    next[0] = j;       // 第一个字符没有前后缀，所以是 -1

    for(int i = 1; i < s.size(); i++) { // i 表示后缀末尾指针，从1开始
        // 如果当前字符不匹配，就回退 j
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j]; // 回退到更短的前缀
        }

        // 如果当前字符匹配成功，则前缀长度+1
        if (s[i] == s[j + 1]) {
            j++;
        }

        // 记录当前 i 的最长相等前后缀长度
        next[i] = j;
    }
}
```

### 使用 next 数字来做匹配
在文本串 s 里找是否出现过模式串 t  
定义两个下标， j 指向模式串起始位置，i 指向文本串起始位置  
用 i 从 0 遍历文本串，然后用 s[i] 与 t[j + ] 进行比较  
如果 s[i] 与 t[j + 1] 不同， j 就要从 next 数组中寻找下一个匹配位置  
如果相同，那么 i 与 j 同时向后移动  
如何判断文本串 s 中出现了模式串 t 呢？  如果 j 指向了模式串 t 的末尾，那么就说明 模式串 t 完全匹配文本串中的某个子串了  
用 next 数组匹配代码如下：
```c++
int j = -1;                               // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) {      // 注意i就从0开始
    while (j >= 0 && s[i] != t[j + 1]) {  // 不匹配
        j = next[j];                      // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) {  // 匹配，j和i同时向后移动
        j++;                 // i的增加在for循环里
    }
    if (j == (t.size() - 1)) {  // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```
对于匹配完的逻辑，可以想一下，如果 s = t = abc，那么当 c == c 的时候，j++ ，这时 j = 2，也就是等于 t.size() -1  

### 回到题目
本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。
前缀表减 1 整体代码如下：
```c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回退
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
		vector<int> next(needle.size());
		getNext(&next[0], needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

### 前缀表不减 1 实现（更推荐）
代码如下：
```c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) { // j > 0 ，和减1版区别
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {// j > 0 ，和减1版区别
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```
更推荐不减 1 的实现  

## 459. 重复的子字符串
[题目链接](https://leetcode.cn/problems/repeated-substring-pattern/description/)  
题意：给一个非空字符串 s ，检查是否可以通过由它的一个子串重复多次构成（也就是说是这个子串的多次拷贝连接）  
思路：计算 next 数组，如果存在重复，重复单元长度应该为 `len - next[len - 1]`，看看整个长度能否被重复单元长度整除  
注意：next[i] 表示以 i 为结尾的字符串的最长公共前后缀，因为下标从 0 开始，所以要 len - 1  
代码如下：
```c++
class Solution {
   public:
    bool repeatedSubstringPattern(string s) {
        int j = 0;
        vector<int> next(s.size());
        next[0] = j;
        for (int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
        if (next[s.size() - 1] > 0 && s.size() % (s.size() - next[s.size() - 1]) == 0) {
            return 1;
        } else
            return 0;
    }
};
```
另一种解法，如果一个字符串是由重复子串构成的，那么把它拼接两次后，在中间部分一定能找到原字符串。  
就是说  S = P + P + P + P....+ P 重复 n 次，那么 S + S = P + P ......+P 有 2n 个 P ，掐头去尾能找到 n 个 P 就说明存在  
对于非重复字符串，S = A + B ，拼接后 S + S = A + B + A + B，这样中间不可能有 A + B  
代码如下：
```c++
class Solution {
   public:
    bool repeatedSubstringPattern(string s) { 
        // 不等于 s 长度的时候，就是在中间找到了
    	if((s + s).find(s, 1) != s.size()){
            return 1;
    	}
        // 等于 s 长度的话，就是全部匹配了一遍，在最后才找到，这样就不符合
        else return 0;

    }
};
```


参考：[代码随想录](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  