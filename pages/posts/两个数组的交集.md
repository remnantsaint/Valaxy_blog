---
layout: post
title: 两个数组的交集
date: 2025-08-12 08:35:22
cover: 
top: 
tags: 
 - 哈希表
categories: 
 - 算法基础
 - 哈希表
# author: @Remsait
---
## 349. 两个数组的交集
[题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/description/)  
题意：给两个数组，编写一个函数来计算它们的交集  
思路：  
就是记录两个数组同时出现的数，再输出这些数  
使用 unordered_set ，这个数据结构中的数据不重复  
代码如下：
```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```
！！其中 `.find()`是查找元素在不在，不在的话会返回`.end()`  
`nums1.begin(), nums1.end()` 并不是直接遍历一遍 set，而是拿到一个迭代器范围，这个范围可以用来：遍历容器（比如用 for 或 while）；或者用来初始化另一个容器（这里就是用来初始化 unordered_set）  
具体 unordered_set 方法见[哈希表理论基础](https://remsait.com/posts/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)  

## 350. 两个数组的交集 Ⅱ
[题目链接](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)  
题意：给两个数组 a 和 b ，以数组形式返回两数组的交集，返回结果中每个元素可以重复出现（与再两个数组中同时出现次数一致）  
思路：用 ordered_map 来计数，或者用 multiset，前者优点更快，后者优点更简洁   
用 ordered_map 代码如下：
```c++
class Solution {
   public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> freq;  // 记录 nums1 中元素频率
        vector<int> result;
        // 统计 nums1 中的每个数字出现次数
        for (int num : nums1) {
            freq[num]++;
        }
        // 遍历 nums2，匹配并减少次数
        for (int num : nums2) {
            if (freq[num] > 0) {  // 存在且次数大于 0
                result.push_back(num);
                freq[num]--;  // 用掉一次
            }
        }
        return result;
    }
};
```
用 multiset 代码如下
```c++
class Solution {
   public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        multiset<int> ms(nums1.begin(), nums1.end());  // 存 nums1 所有元素
        vector<int> result;
        for (int num : nums2) {
            auto it = ms.find(num);  // ！！按迭代器删除在 multiset 中找
            if (it != ms.end()) {    // 找到了
                result.push_back(num);
                ms.erase(it);  // 按迭代器删除（只删一个）
            }
        }
        return result;
    }
};
```
`s.erase(value)`     ！！按值删除，删除所有等于 value 的元素  
`s.erase(iterator)`  ！！按迭代器删除，只删除迭代器指向的那个元素  
按迭代器删除要先用`auto it = ms.find(num)`来定义迭代器  







参考：[代码随想录](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)