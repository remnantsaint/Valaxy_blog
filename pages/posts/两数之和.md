---
layout: post
title: 两数之和
date: 2025-08-13 08:47:02
cover: 
top: 
tags: 
 - 哈希表
categories: 
 - 算法基础
 - 哈希表
# author: @Remsait
---
## 1. 两数之和
[题目链接](https://leetcode.cn/problems/two-sum/)  
题意：给一个整数数组和一个目标值，在数组中找到为目标值的两个数，并返回下标  
思路：使用哈希法，用 map 存放数值和下标  
代码如下：
```c++
class Solution {
   public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> s;
        for (int i = 0; i < nums.size(); i++) {
            if (s.count(target - nums[i])!=0) {
                return {i, s[target - nums[i]]};
            }
            s[nums[i]] = i;
        }
        return {};
    }
};
```
其中 `s.count(x) != 0` 表示 x 在map s 中  

## 454. 四数相加Ⅱ
[题目链接](https://leetcode.cn/problems/4sum-ii/description/)  
题意：给四个整数数组，数组长度都是 n ，计算有多少个元组 `(i, j, k, l)`满足 `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`  
思路：用哈希法，前两个数组相加记录，再后两个数组相加记录，最后用哈希表判断一下前后两个相加的值，时间复杂度为 $O(n^2)$ ，因为要两层 for 遍历两个数组  
代码如下：

```c++
class Solution {
   public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap;
        // key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0;  // 统计a+b+c+d = 0 出现的次数
        // 再遍历大C和大D数组，找到如果 0-(c+d)
        // 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                    // 前面两个数组不同数相加可能相等
                }
            }
        }
        return count;
    }
};
```

## 15. 三数之和
[题目链接](https://leetcode.cn/problems/3sum/description/)  
题意：给一个包含 n 个整数的数组 nums ，判断 nums 中是否存在三个元素 a , b , c 使得 a + b + c = 0 ？找出所有满足条件**不重复**三元组  
思路：  
本题若用哈希解法，两层 for 确定两个数值，再用哈希法来确定第三个数，思路正确，但是不好判断是否重复  
把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时  
所以需要用到**双指针**，定义一个 i 在数组起点，定义 left 和 right 在起点后的起点和终点，每轮遍历 i++ ，如果 `nums[i] + nums[left] + nums[right] > 0`说明此时三数之和大，因为数组是排序后的，所以 right 下标向左移动，`nums[i] + nums[left] + nums[right] < 0`同理，让 left 向右移动，直到 left 与 right 相遇为止  
为什么不会 “错过” 正确解？  
假设存在一组满足条件的 (i, left, right) ，排序后数组是升序的，那么：  
如果当前三数之和 大于 0，说明 nums[right] 太大，必须让 right 左移（减小总和），否则固定 right 不动、只动 left ，总和只会越来越大（因为 left 右移后 nums[left] 更大 ），永远无法得到 0 。  
如果当前三数之和 小于 0，说明 nums[left] 太小，必须让 left 右移（增大总和），否则固定 left 不动、只动 right ，总和只会越来越小（right 左移后 nums[right] 更小 ），也无法得到 0 。  
所以，通过 “大了右指针左移，小了左指针右移” 的逻辑，能覆盖所有可能的组合，不会错过正确解。  
代码如下：
```c++
class Solution {
   public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;  // 输出的是多个三元组
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了
                // 0,0,0 这种三元组
                if (nums[i] + nums[left] + nums[right] > 0){
                    right --;
                }
                else if (nums[i] + nums[left] + nums[right] < 0){
                    left++;
                }
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重'
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```
### 去重逻辑的思考
#### a的去重
去重主要考虑三个数的去重，a b c 对应的就是nums[i]，nums[left]，nums[right] ， a 是 nums 中遍历的元素，不用管  
这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同，两者肯定不一样，如果写法如下：  
```c++
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```
这样就把三元组中出现重复元素的情况直接pass掉了。 例如 {-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。  
我们要的是不能有重复的三元组，但三元组内的元素数值可以重复，所以应该如下写法  
```c++
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```
这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。  
#### b 与 c 的去重
很多人写的时候，去重逻辑多加了对 right 和 left 的去重，如下：
```c++
while (right > left) {
    if (nums[i] + nums[left] + nums[right] > 0) {
        right--;
        // 去重 right
        while (left < right && nums[right] == nums[right + 1]) right--;
    } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++;
        // 去重 left
        while (left < right && nums[left] == nums[left - 1]) left++;
    } else {
    }
}
```
其实不需要，只在找到答案的时候再去重就够了  



## 18. 四数之和
[题目链接](https://leetcode.cn/problems/4sum/description/)  
题意：给一个含有 n 个元素的数组 nums 以及一个目标值 target，找出满足相加等于 target 且**不重复**的四元组  
思路：和 三数之和 是一个思路，都是用双指针法，在其基础上再加一层 for 循环  
但是有一些细节要注意，一开始的剪枝不能简单地 nums[i] > target 就 return ，因为 target 是一个不确定的值，可能大于 0 可能小于 0，需要修改一下逻辑：`nums[k] > target && (nums[k] >=0 || target >= 0)`  
四数之和的解法是两层 for 循环 nums[k] + nums[i] 为确定之，依然是循环内有 left 和 right 下标作为双指针，找出`nums[k] + nums[i] + nums[left] + nums[right] == target`的情况，时间复杂度为$O(n^3)$  
[四数相加Ⅱ](https://leetcode.cn/problems/4sum-ii/description/) 相比本题简单很多，因为本题要求在一个集合中找出四个数相加等于 target ，同时四元组不能重复，而前者是四个独立的数组，不用考虑有重复的四个元素  
代码如下：
```c++
class Solution {
   public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 剪枝处理
            if (nums[k] > target && nums[k] >= 0) {
                break;  // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long)nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                        // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                    } else if ((long)nums[k] + nums[i] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```
双指针法重要的是 **剪枝** 与 **去重** 的逻辑  







参考：[代码随想录](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html)  