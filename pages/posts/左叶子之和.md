---
layout: post
title: 左叶子之和
date: 2025-09-06 09:51:27
updated: 2025-09-06
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories:
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 404. 左叶子之和
[题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)  
题意：计算给定二叉树的所有 左叶子 之和
思路：  
左叶子是结点A的左孩子不为空，且左孩子的左右孩子都为空，那么A结点的左孩子为左叶子结点  
### 方法一（递归
```c++
class Solution {
public:
    int result = 0;
    void dfs(TreeNode* cur){
        if(cur == NULL) return;
        if(cur->left != NULL && cur->left->left == NULL && cur->left->right == NULL){
            result += cur->left->val;
        }
        dfs(cur->left);
        dfs(cur->right);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL) return result;
        dfs(root);
        return result;
    }
};
```
### 方法二（迭代
```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```
## 513. 找树左下角的值
[题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)  
题意：给定一个二叉树的根节点，找出该二叉树的最底层最左边结点的值  
### 递归
思路：要找深度最大的叶子节点，可以使用前序遍历，保证优先搜索左边，然后记录深度最大的叶子节点（本质是求深度，可以参考平衡二叉树  
代码如下：  
```c++
class Solution {
public:
    int result;
    int maxDepth = INT_MIN;
    void traversal(TreeNode* root, int depth){
        if(root == NULL) return ;
        if(root->left == NULL && root->right == NULL){
            if(depth > maxDepth){
                maxDepth = depth;
                result = root->val;
            }
        }
        if(root->left){
            traversal(root->left, depth + 1); // 隐藏回溯
        }
        if(root->right){
            traversal(root->right, depth +1);
        }
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root,0);
        return result;
    }
};
```
### 迭代
思路：迭代法比递归更简单点，只需要记录最后最后一行第一个结点的数值  
代码如下：  
```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```












参考：[代码随想录](https://programmercarl.com/)  











