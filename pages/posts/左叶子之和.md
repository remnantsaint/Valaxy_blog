---
layout: post
title: 左叶子之和
date: 2025-09-06 09:51:27
updated: 2025-09-07
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories:
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 404. 左叶子之和
[题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)  
题意：计算给定二叉树的所有 左叶子 之和
思路：  
左叶子是结点A的左孩子不为空，且左孩子的左右孩子都为空，那么A结点的左孩子为左叶子结点  
### 方法一（递归
```c++
class Solution {
public:
    int result = 0;
    void dfs(TreeNode* cur){
        if(cur == NULL) return;
        if(cur->left != NULL && cur->left->left == NULL && cur->left->right == NULL){
            result += cur->left->val;
        }
        dfs(cur->left);
        dfs(cur->right);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL) return result;
        dfs(root);
        return result;
    }
};
```
### 方法二（迭代
```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                result += node->left->val;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```
## 513. 找树左下角的值
[题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)  
题意：给定一个二叉树的根节点，找出该二叉树的最底层最左边结点的值  
### 递归
思路：要找深度最大的叶子节点，可以使用前序遍历，保证优先搜索左边，然后记录深度最大的叶子节点（本质是求深度，可以参考平衡二叉树  
代码如下：  
```c++
class Solution {
public:
    int result;
    int maxDepth = INT_MIN;
    void traversal(TreeNode* root, int depth){
        if(root == NULL) return ;
        if(root->left == NULL && root->right == NULL){
            if(depth > maxDepth){
                maxDepth = depth;
                result = root->val;
            }
        }
        if(root->left){
            traversal(root->left, depth + 1); // 隐藏回溯
        }
        if(root->right){
            traversal(root->right, depth +1);
        }
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root,0);
        return result;
    }
};
```
### 迭代
思路：迭代法比递归更简单点，只需要记录最后最后一行第一个结点的数值  
代码如下：  
```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## 112. 路径总和
[题目链接](https://leetcode.cn/problems/path-sum/description/)  
题意： 给一颗二叉树的根节点和一个表示目标和的整数 targetSum ，判断该树种是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum ，如果存在返回 true，否则返回 false  
思路： 递归遍历，利用好回溯  
代码如下：  
```c++
class Solution {
public:
    int flag = 0;
    void dfp(TreeNode* root, int sum, int targetSum){
        if(flag == 1){
            return;
        }
        if(root == NULL){
            return;
        }
        sum += root->val;
        if(root->left == NULL && root->right == NULL && sum == targetSum){
            flag = 1;
        }
        if(root->left != NULL) {
            dfp(root->left, sum,targetSum);
        }
        if(root->right != NULL){
            dfp(root->right, sum,targetSum);
        }
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        dfp(root,0,targetSum);
        return flag;
    }
};
```
也可以使用栈模拟递归，也就是迭代法，代码如下：  
```c++
class solution {

public:
    bool haspathsum(TreeNode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<TreeNode*, int>> st;
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty()) {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```

### 113. 路径综合 Ⅱ
[题目链接](https://leetcode.cn/problems/path-sum-ii/description/)  
题意：在上一题的基础上，找出所有从根节点到叶子节点的路经综合等于给定目标的路径  
思路：在上一题的基础上，多加一个存路径的变量  
代码如下：  
```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void dfp(TreeNode* root, int sum, int targetSum){
        if(root == NULL){
            return;
        }
        sum += root->val;
        path.push_back(root->val);
        if(root->left == NULL && root->right == NULL && sum == targetSum){
            result.push_back(path);
        }
        dfp(root->left, sum,targetSum); // 开头已判断 == NULL
        dfp(root->right, sum,targetSum);
        path.pop_back(); // 只弹出 root 即可
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfp(root,0,targetSum);
        return result;
    }
};
```


















参考：[代码随想录](https://programmercarl.com/)  











