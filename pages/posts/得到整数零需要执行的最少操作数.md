---
layout: post
title: 得到整数零需要执行的最少操作数
date: 2025-09-05 09:57:11
updated: 2025-09-05
time_warning: true 
cover: 
top: 
tags: 
 - 数学
 - 二进制
 - 枚举
categories: 
 - 题解
 - 数学
# author: @Remsait
---
[题目链接](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/description/)  
题意：给两个整数 num1 与 num2 ，在一步操作中，需要从范围 [0, 60] 中选出一个整数 i ，并从 num1 减去 $2^i + num2$，计算要想使 num1 最后减为 0，需要的最少操作数，并以整数形式返回，如果无法使 num1 等于 0，则返回 -1  
思路：在代码注释  
代码如下：  
```c++
class Solution {
public:
    int makeTheIntegerZero(int num1, int num2) {
        for (int i = 1; i <= 60; i++) {
            long long x = (long long)num1 - (long long)i * num2;
            int count = 0;
            if (x <= 0 || x < i) {
                continue;
            }
            //二进制下求 1 的个数
            while (x) {
                x = x & (x - 1);
                count++;
            }
            if (count <= i) {
                return i;
            }
        }
        return -1;
    }
};
/*
num1 - i(num2) = 2^m + 2^j + ..... + 2^k
后部分不能小于1，i 大于等于1，所以 num1 - i(num2) 大于等于1
判断 num1 - i * num2 是否是 i 个 2 的任意次幂相加
每个 2 的幂至少为 1，所以 i 个 2 幂至少为i，所以 nm1 - p(num2) 大于等于 i
有了 x 不能小于 i 之后，x 至少能被 i 个 1 来组成，所以count <= i 合理

单要证明一个数能否被 i 个 2 的任意次幂相加得到
有三个条件：“正整数” “至少为 i” “二进制中 1 的个数 ≤ i”

计算 x 的时候，得让 i 和 num1 都转化为 long long，前者避免乘法溢出，后者避免减法溢出
while (x) {
    x = x & (x - 1);
    count++;
}
可以高效计算 x 中有多少个 1
*/
```