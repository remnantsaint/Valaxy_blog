---
layout: post
title: 得到整数零需要执行的最少操作数
date: 2025-09-05 09:57:11
updated: 2025-09-05
time_warning: true 
cover: 
top: 
tags: 
 - 数学
 - 二进制
 - 枚举
categories: 
 - 题解
 - 数学
# author: @Remsait
---
## 2749. 得到整数零需要执行的最少操作数
[题目链接](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/description/)  
题意：给两个整数 num1 与 num2 ，在一步操作中，需要从范围 [0, 60] 中选出一个整数 i ，并从 num1 减去 $2^i + num2$，计算要想使 num1 最后减为 0，需要的最少操作数，并以整数形式返回，如果无法使 num1 等于 0，则返回 -1  
思路：在代码注释  
代码如下：  
```c++
class Solution {
public:
    int makeTheIntegerZero(int num1, int num2) {
        for (int i = 1; i <= 60; i++) {
            long long x = (long long)num1 - (long long)i * num2;
            int count = 0;
            if (x <= 0 || x < i) {
                continue;
            }
            //二进制下求 1 的个数
            while (x) {
                x = x & (x - 1);
                count++;
            }
            if (count <= i) {
                return i;
            }
        }
        return -1;
    }
};
/*
num1 - i(num2) = 2^m + 2^j + ..... + 2^k
后部分不能小于1，i 大于等于1，所以 num1 - i(num2) 大于等于1
判断 num1 - i * num2 是否是 i 个 2 的任意次幂相加
每个 2 的幂至少为 1，所以 i 个 2 幂至少为i，所以 nm1 - p(num2) 大于等于 i
有了 x 不能小于 i 之后，x 至少能被 i 个 1 来组成，所以count <= i 合理

单要证明一个数能否被 i 个 2 的任意次幂相加得到
有三个条件：“正整数” “至少为 i” “二进制中 1 的个数 ≤ i”

计算 x 的时候，得让 i 和 num1 都转化为 long long，前者避免乘法溢出，后者避免减法溢出
while (x) {
    x = x & (x - 1);
    count++;
}
可以高效计算 x 中有多少个 1
*/
```


## 3495. 使数组元素都变为零的最少操作数
[题目链接](https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/?envType=daily-question&envId=2025-09-06)  
题意：在 [l, r] 区间内的所有数，每次取两个数除以4，求出让所有数都为 0 的最小操作数  
思路：计算出每个数变为 0 需要的次数，然后加一起除以 2 就行（必然存在结果  
代码如下：  
```c++
class Solution {
    using ll = long long;
public:
    int d(int x){
        int count = 0;
        while(x){
            x = x / 4;
            count ++;
        }
        return count;
    }
    long long minOperations(vector<vector<int>>& queries) {
        long long result = 0;
        for(int i = 0; i < queries.size(); i++){
            int l = queries[i][0], r = queries[i][1];
            int x = d(l);
            int y = d(r);
            if(x == y){
                result += ceil(double(r - l + 1) * x / 2);
            }
            else {
                long long m = (pow(4,x) - l) * x + (r - pow(4,y-1) + 1) * y;
                long long n = 0;
                int x1 = x;
                while(1){
                    x1++;
                    if(x1 == y){
                        break;
                    }
                    n += (pow(4,x1) - pow(4,(x1-1))) * x1; 
                }
                result += ceil(double(m + n) / 2);
            }
        }
        return result;
    }
};
/*
计算 l 到 r 每个数需要的操作次数，全部加起来除以2

注意当操作数为奇数时，应当向上取整

*/
```























