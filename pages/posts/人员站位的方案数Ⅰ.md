---
layout: post
title: 人员站位的方案数Ⅰ
date: 2025-09-02 11:27:46
updated: 2025-09-02
time_warning: true 
cover: 
top: 
tags: 
 - 排序
 - 几何
categories: 
 - 题解
 - 几何
# author: @Remsait
---
## 3025. 人员站位的方案数 Ⅰ
[题目链接](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/description/?envType=daily-question&envId=2025-09-02)  
  题意：  
  给一个 n × 2 的二维数组 points，表示平面上的一些点坐标，计算 (A, B) 的数量，其中 A 在 B 的左上角，它们形成的长方形或直线上没有其他点，返回数量  
  
  思路：  
  首先给二维数组按 x 来排序，从小到大，如果 x 相等就按 y 来排序，y 从大到小  
  先来一层 for 遍历每个点(i)，再来一层 for 遍历(j)后面的点和该点能否达到要求  
  可知对于每个点来说，以其后面第一个符合 $x_j >= x_i ，y_j <= y_i$ 的 $y_j$ 为基准，使 $y_{min} = y_j$ ，后面的点必须符合 $y_{min} < y_j <= y_i$ ，这样才能达到要求
  
  代码如下：
```c++
class Solution {
    typedef vector<int> v;
public:
    int numberOfPairs(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const v& v1, const v& v2) {
            return v1[0] == v2[0] ? v1[1] > v2[1]:v1[0] < v2[0];
            });
        int ans = 0;
        for (int i = 0; i < points.size(); i++) {
            int x1 = points[i][0], y1 = points[i][1];
            int miny = INT_MIN;
            for (int j = i + 1; j < points.size(); j++) {
                int x2 = points[j][0], y2 = points[j][1];
                if (y2 > y1) continue;
                if (y2 > miny) {
                    ans++;
                    miny = y2;
                }
            }
        }
        return ans;
    }
};
```

！！！注意给二维数组写排序的 **lambda** 方法