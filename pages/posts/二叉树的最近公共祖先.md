---
layout: post
title: 二叉树的最近公共祖先
date: 2025-09-11 12:20:11
updated: 2025-09-11
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 236. 二叉树的最近公共祖先
[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)  
题意：给定一个二叉树，找到该树中两个指定节点的最近公共祖先（一个结点也可以是它自己的祖先）  
思路：  
  自底向上查找，就能找到公共祖先，后序遍历是天然的回溯过程，可以根据左右子树的返回值，来处理中间结点的逻辑  
  
  如何判断一个结点是结点 q 和结点 p 的公共祖先？如果递归遍历遇到 q 就将 q 返回，如果遇到 p 就将 p 返回，如果左右子树的返回值都不为空，说明此时的中结点一定是 p 和 q 的最近祖先  
  
  如果只有一个子树为空，就返回不为空的值  
  
  代码如下：  
```c++
class Solution {
public:
    TreeNode* dfs(TreeNode* root, TreeNode* p, TreeNode* q){
        if(root == q || root == p || root == NULL) return root;
        TreeNode* left = dfs(root->left, p, q);
        TreeNode* right = dfs(root->right, p, q);
        if(left != NULL && right != NULL) return root;

        if(left == NULL && right != NULL) return right;
        else if(left != NULL && right == NULL) return left;
        else { // left == NULL && right == NULL
            return NULL;
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* ans = dfs(root, p, q);
        return ans;
    }
};
```
总结：  
1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历
2. 在回溯过程中，必然要遍历整棵二叉树，即使已经找到结果，依然要把其他结点遍历完，因为要使用递归函数的返回值（也就是代码中的 left 和 right）做逻辑判断  
3. 要理解如果返回值 left 为空，right 不为空为什么要返回 right，为什么可以用返回 right 传给上一层结果
  
## 235. 二叉搜索树的最近公共祖先
[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)  
题意：和上一题相同，只是把二叉树变为二叉搜索树  
思路：  
  二叉搜索树和二叉树的区别是有序的，如果是 p 和 q 的祖先，那么其数值必然在 [p, q] 之间  
  
  可以证明的是，在遍历的过程中，第一次找到的在 [p, q] 之间的数就是祖先节点  
  
  代码如下：
```c++
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return NULL;
        if (cur->val > p->val && cur->val > q->val) {   // 左
            return traversal(cur->left, p, q);
        }
        if (cur->val < p->val && cur->val < q->val) {   // 右
            return traversal(cur->right, p, q);
        }
        return cur;
}
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```
  迭代法在搜索树的代码上微改，很简单  
  感觉二叉搜索树不涉及回溯的话用迭代法更好  
















参考：[代码随想录](https://www.programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  