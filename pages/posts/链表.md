---
categories: 
 - 算法基础
 - 链表
cover: 
date: 2023-04-03 18:04:57
image: 
layout: post
tags: 
 - 链表
time_warning: true
title: 链表
top: 
---
链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null   
链表的入口节点称为链表的头结点，也就是 head  
## 链表的类型
### 单链表
### 双链表
单链表中的指针域只能指向节点的下一个节点  
双链表中每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点  
双链表既可以向后查询，也可以向前查询  
### 循环链表
循环链表就是首尾相连，可以用来解决约瑟夫环的问题  
## 链表的存储方式
数组在内存中是连续分布的，但是链表在内存中可不是连续分布的  
链表是通过指针域的指针链接在内存中各个节点  
所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理
## 链表的定义
C/C++定义链表代码如下：  
```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
其中的构造函数的目的是可以直接给变量赋值，比如用
```c++
ListNode* head = new ListNode(5);
```
来代替  
```c++
ListNode* head = new ListNode();
head->val = 5;
```
## 链表的操作
### 删除节点
只要将想删除的节点前一个节点的 Next 指向后一个节点就行了  
C++还要手动释放内存，java 和 python 有内存回收机制，不用手动释放  
### 添加节点
用要插入的位置的前一个节点的 next 指向该节点  
然后该节点的 next 指向后一个节点  
## 总示例代码 
包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并  
```c++
#include <stdlib.h>
#include <stdio.h>

int n, i;
int a[100];

typedef struct LNode
{
    int data;
    struct LNode *next;
} *List, node; // List和node * 同义

void HeadCreatList(List H) // 头插法，逆序插入
{
    node *p;
    for (i = 1; i <= n; i++)
    {
        p = (List)malloc(sizeof(List));
        p->data = a[i];
        p->next = H->next;
        H->next = p;
    }
}

void TailCreatList(List H) // 尾插法，顺序插入
{
    node *p, *r;
    r = H; // r是尾指针，一直指向最后一个结点
    for (i = 1; i <= n; i++)
    {
        p = (List)malloc(sizeof(List));
        p->data = a[i];
        r->next = p;
        r = p;
    }
    r->next = NULL; // r是最后一个结点，最后一个节点后接空
}

node *Search(List H, int x, int *w) // 查找x在链表中的下标
{
    node *p;
    int n = 0;
    p = H->next;
    while (p != NULL && p->data != x)
    {
        p = p->next;
        n++;
    }
    if (p != NULL)
    {
        *w = n + 1; // 因为当p->data==x时就跳出循环，所以加1
        return p;
    }
    else
    {
        *w = 0;
        return NULL;
    }
}

void Delete(List H, int x) // 删除为x的数据
{
    node *pre, *p, *q;
    pre = H;     // pre用作前驱
    p = H->next; // p是当前结点
    while (p != NULL)
    {
        if (p->data == x)
        {
            q = p; // 存结点
            pre->next = p->next;
            p = pre->next;
            free(q); // 释放结点
        }
        else
        {
            pre = pre->next;
            p = p->next;
        }
    }
}

void Insert(List H, int x) // 将x插入链表中的第一个大于它的数的前边
{
    node *pre, *p, *q;
    pre = H; // 前驱
    p = H->next;
    while (p != NULL && p->data < x)
    { // p停在第一个大于等于x的结点
        pre = pre->next;
        p = p->next;
    }
    q = (List)malloc(sizeof(List));
    q->data = x;
    pre->next = q;
    q->next = p;
} // 若想创建一个有序的链表，就输入每个值然后调用一次Insert就好

void print(List H)
{
    node *p;
    p = H->next;
    while (p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

void reverseList(node *head) // 反转链表，注意这里head是H->next
{
    node *pre, *p;
    pre = NULL; // pre一开始在头结点
    p = head;   // p一开始在首元结点
    while (p != NULL)
    {
        node *q = p->next;
        p->next = pre; // 改变p点的指针指向
        pre = p;       // 将pre移向下一个结点
        p = q;         // 将p移向下一个结点
    }
}

node *middleNode(node *head) // 找链表中点，注意这里head是H->next
{
    node *first = head, *second = head; // 快慢指针
    while (first != NULL && first->next != NULL)
    {
        first = first->next->next;
        second = second->next;
    }
    return second;
}

void mergeList(node *l1, node *l2) // 相邻挨个插入
{
    node *l1_tmp;
    node *l2_tmp;
    while (l1 != NULL && l2 != NULL)
    {
        l1_tmp = l1->next; // 因为要改变结点的next
        l2_tmp = l2->next; // 所以先用tmp结点存当前结点的next结点

        l1->next = l2;
        l1 = l1_tmp;

        l2->next = l1;
        l2 = l2_tmp;
    }
}

int main()
{
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    List H;
    H = (List)malloc(sizeof(List));
    H->next = NULL;

    TailCreatList(H);
    print(H);

    int x, w;

    printf("要查找的数据：");
    scanf("%d", &x);
    node *z = Search(H, x, &w);
    if (z == NULL)
    {
        printf("不在链表中\n");
    }
    else
        printf("在链表中下标为：%d\n", w);

    printf("要删除的数据：");
    scanf("%d", &x);
    Delete(H, x);
    printf("删除后：");
    print(H);

    printf("要插入的数据（递增）：");
    scanf("%d", &x);
    Insert(H, x);
    printf("插入后：");
    print(H);

    return 0;
}
```