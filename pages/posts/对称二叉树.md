---
layout: post
title: 对称二叉树
date: 2025-09-01 16:21:04
updated: 2025-09-01
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories:
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 101. 对称二叉树
[题目链接](https://leetcode.cn/problems/symmetric-tree/)  
题意：给一个二叉树的根节点，检查它是否轴对称  
### 方法一
思路：既然要检查对称，就是要检查根节点的左右两颗子树是否对称，要想好用到什么样的遍历方法去比较，即左子树和右子树都用前序遍历，但是右子树用 中右左方式。！！！注意空结点一定要标记为空  
代码如下：  
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        vector<string> leftSeq, rightSeq;
        // 左子树：中左右
        preorderLeft(root->left, leftSeq);
        // 右子树：中右左  
        preorderRight(root->right, rightSeq);
        return leftSeq == rightSeq;
    }
private:
    void preorderLeft(TreeNode* node, vector<string>& seq) {
        if (!node) {
            seq.push_back("null");  // 关键：记录空节点
            return;
        }
        seq.push_back(to_string(node->val));
        preorderLeft(node->left, seq);
        preorderLeft(node->right, seq);
    }
    void preorderRight(TreeNode* node, vector<string>& seq) {
        if (!node) {
            seq.push_back("null");  // 关键：记录空节点
            return;
        }
        seq.push_back(to_string(node->val));
        preorderRight(node->right, seq);  // 先右
        preorderRight(node->left, seq);   // 后左
    }
};
```

### 方法二
思路：同时遍历两颗子树，但是方向相反，不需要额外空间  
代码如下：  
```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```

### 方法三
思路：用迭代法，使用一个队列来模拟左右同时遍历，看队头的两个值是否相等  
代码如下：  
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```


















参考：[代码随想录](https://www.programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)