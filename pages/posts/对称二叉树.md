---
layout: post
title: 对称二叉树
date: 2025-09-01 16:21:04
updated: 2025-09-04
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories:
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 101. 对称二叉树
[题目链接](https://leetcode.cn/problems/symmetric-tree/)  
题意：给一个二叉树的根节点，检查它是否轴对称  
### 方法一
思路：既然要检查对称，就是要检查根节点的左右两颗子树是否对称，要想好用到什么样的遍历方法去比较，即左子树和右子树都用前序遍历，但是右子树用 中右左方式。！！！注意空结点一定要标记为空  
代码如下：  
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        vector<string> leftSeq, rightSeq;
        // 左子树：中左右
        preorderLeft(root->left, leftSeq);
        // 右子树：中右左  
        preorderRight(root->right, rightSeq);
        return leftSeq == rightSeq;
    }
private:
    void preorderLeft(TreeNode* node, vector<string>& seq) {
        if (!node) {
            seq.push_back("null");  // 关键：记录空节点
            return;
        }
        seq.push_back(to_string(node->val));
        preorderLeft(node->left, seq);
        preorderLeft(node->right, seq);
    }
    void preorderRight(TreeNode* node, vector<string>& seq) {
        if (!node) {
            seq.push_back("null");  // 关键：记录空节点
            return;
        }
        seq.push_back(to_string(node->val));
        preorderRight(node->right, seq);  // 先右
        preorderRight(node->left, seq);   // 后左
    }
};
```

### 方法二（递归
思路：同时遍历两颗子树，但是方向相反，不需要额外空间  
代码如下：  
```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```

### 方法三（迭代
思路：用迭代法，使用一个队列来模拟左右同时遍历，看队头的两个值是否相等  
代码如下：  
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

## 100. 相同的树
[题目链接](https://leetcode.cn/problems/same-tree/description/)  
题意：给两颗树，判断是否相同  
思路：递归遍历判断，先列出一堆判断，通过了就是相同的节点，然后接着递归，直到不同停下，或者遍历到叶子节点返回 1  
代码如下：
```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right){
       if (left == NULL && right != NULL) return false;
       else if (left != NULL && right == NULL) return false;
       else if (left == NULL && right == NULL) return true;
       else if (left->val != right->val) return false;
       
       bool a = compare(left->left, right->left);
       bool b = compare(left->right, right->right);
       bool isSame = a && b;
       return isSame;
    }
    bool isSameTree(TreeNode* p, TreeNode* q) {
        return compare(p, q);
    }
};
```

## 572. 另一棵树的子树
[题目链接](https://leetcode.cn/problems/subtree-of-another-tree/description/)  
题意：给两颗二叉树，检验其中一棵树是否包含和另一棵树具有相同结构的节点值的子树  
### 方法一（暴力匹配
思路：也就是判断后者是否和前者的某个节点开始遍历的树相等，遍历前者树每个节点比较一轮  
```c++
class Solution {
public:
    bool check(TreeNode *o, TreeNode *t) {
        if (!o && !t) {
            return true;
        }
        if ((o && !t) || (!o && t) || (o->val != t->val)) {
            return false;
        }
        return check(o->left, t->left) && check(o->right, t->right);
    }

    bool dfs(TreeNode *o, TreeNode *t) {
        if (!o) {
            return false;
        }
        return check(o, t) || dfs(o->left, t) || dfs(o->right, t);
    }

    bool isSubtree(TreeNode *s, TreeNode *t) {
        return dfs(s, t);
    }
};
```
### 方法二（KMP
```c++
class Solution {
public:
    vector <int> sOrder, tOrder;
    int maxElement, lNull, rNull;

    void getMaxElement(TreeNode *o) {
        if (!o) {
            return;
        }
        maxElement = max(maxElement, o->val);
        getMaxElement(o->left);
        getMaxElement(o->right);
    }

    void getDfsOrder(TreeNode *o, vector <int> &tar) {
        if (!o) {
            return;
        }
        tar.push_back(o->val);
        if (o->left) {
            getDfsOrder(o->left, tar);
        } else {
            tar.push_back(lNull);
        }
        if (o->right) {
            getDfsOrder(o->right, tar);
        } else {
            tar.push_back(rNull);
        }
    }

    bool kmp() {
        int sLen = sOrder.size(), tLen = tOrder.size();
        vector <int> fail(tOrder.size(), -1);
        for (int i = 1, j = -1; i < tLen; ++i) {
            while (j != -1 && tOrder[i] != tOrder[j + 1]) {
                j = fail[j];
            }
            if (tOrder[i] == tOrder[j + 1]) {
                ++j;
            }
            fail[i] = j;
        }
        for (int i = 0, j = -1; i < sLen; ++i) {
            while (j != -1 && sOrder[i] != tOrder[j + 1]) {
                j = fail[j];
            }
            if (sOrder[i] == tOrder[j + 1]) {
                ++j;
            }
            if (j == tLen - 1) {
                return true;
            }
        }
        return false;
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        maxElement = INT_MIN;
        getMaxElement(s);
        getMaxElement(t);
        lNull = maxElement + 1;
        rNull = maxElement + 2;

        getDfsOrder(s, sOrder);
        getDfsOrder(t, tOrder);

        return kmp();
    }
};
```

### 方法三（树哈希
```c++
class Solution {
public:
    static constexpr int MAX_N = 1000 + 5;
    static constexpr int MOD = int(1E9) + 7;

    bool vis[MAX_N];
    int p[MAX_N], tot;
    void getPrime() {
        vis[0] = vis[1] = 1; tot = 0;
        for (int i = 2; i < MAX_N; ++i) {
            if (!vis[i]) p[++tot] = i;
            for (int j = 1; j <= tot && i * p[j] < MAX_N; ++j) {
                vis[i * p[j]] = 1;
                if (i % p[j] == 0) break;
            }
        }
    }

    struct Status {
        int f, s; // f 为哈希值 | s 为子树大小
        Status(int f_ = 0, int s_ = 0) 
            : f(f_), s(s_) {}
    };

    unordered_map <TreeNode *, Status> hS, hT;

    void dfs(TreeNode *o, unordered_map <TreeNode *, Status> &h) {
        h[o] = Status(o->val, 1);
        if (!o->left && !o->right) return;
        if (o->left) {
            dfs(o->left, h);
            h[o].s += h[o->left].s;
            h[o].f = (h[o].f + (31LL * h[o->left].f * p[h[o->left].s]) % MOD) % MOD;
        }
        if (o->right) {
            dfs(o->right, h);
            h[o].s += h[o->right].s;
            h[o].f = (h[o].f + (179LL * h[o->right].f * p[h[o->right].s]) % MOD) % MOD;
        }
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        getPrime();
        dfs(s, hS);
        dfs(t, hT);

        int tHash = hT[t].f;
        for (const auto &[k, v]: hS) {
            if (v.f == tHash) {
                return true;.
            }
        } 

        return false;
    }
};
```
作者：力扣官方题解  
链接：https://leetcode.cn/problems/subtree-of-another-tree/solutions/233896/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/











参考：[代码随想录](https://www.programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)