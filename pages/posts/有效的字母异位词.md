---
layout: post
title: 有效的字母异位词
date: 2025-08-11 08:19:02
cover: 
top: 
tags: 
 - 哈希表
categories: 
 - 算法基础
 - 哈希表
# author: @Remsait
---
## 242. 有效的字母异位词
[题目链接](https://leetcode.cn/problems/valid-anagram/)  
题意：给两个字符串 s 与 t ，编写一个函数来判断 t 是否是 s 的字母异位词  
字母异位词的意思是两个字符串所包含的字母及其个数完全一样，只是位置不同  
思路：  
暴力解法的时间复杂度是 O(n^2)  
定义一个26 大小的数组，初始化为 0，然后遍历两遍字符串，最后再扫描一下自己定义的数组  
时间复杂度为 O(n) ，空间复杂度为 O(n)  
代码如下：  
```c++
class Solution {
   public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```
## 383. 赎金信
[题目链接](https://leetcode.cn/problems/ransom-note/description/)  
题意：给两个字符串，判断 a 能否被 b 的字符所组成，b 中字符只能用一次（b 可以比 a 大）  
思路：哈希数组，先遍历 b ，然后遍历 a，如果第二次遍历 a 的时候有不存在字符，就 false   
代码如下  
```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        bool flag = true;
        for(int i = 0; i < magazine.size(); i++){
            record[magazine[i] - 'a']++;
        }
        for(int i = 0; i < ransomNote.size(); i++){
            record[ransomNote[i] - 'a']--;
            if(record[ransomNote[i] - 'a'] == -1){
                flag = false;
            }
        }
        return flag;
    }
};
```

## 49. 字母异位词分组
[题目链接](https://leetcode.cn/problems/group-anagrams/)  
题意：给一个字符串数组，然后把是字母异位词的分在一起  
思路：定义一个哈希集合，对每个字符串排序，然后再加入哈希集合  
要用到 sort 函数，对字符串内的字符排序，`sort(s.begin(),s.end())`
代码如下：
```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;
        for(string s : strs){
            string key = s;
            sort(key.begin(), key.end());
            map[key].push_back(s);
        }
        vector<vector<string>> result;
        //!!! 用pair遍历map
        for(auto& pair : map){
            result.push_back(pair.second);
        }
        return result;
    }
};
```
！！用 pair 遍历键值对，`for(auto& pair : map)`，其中 `pair.first`是 key ，`pair.second`是 value，vector 用`push_back()`来添加元素

## 438. 找到字符串中所有字母异位词
[题目链接](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)  
题意：给两个字符串 a 与 b ，在 a 中找所有 p 的异位词的字串，然后返回每个索引  
思路：在 a 字符串中用滑动窗口，记录窗口内字符个数，然后滑动匹配（应该用滑动窗口计数法，直接用字符串截取匹配的话会超时）  
代码如下：
```c++
class Solution {
   public:
    vector<int> findAnagrams(string s, string p) {
        int slen = s.size();
        int plen = p.size();
        if (slen < plen) {
            return {};
        }
        vector<int> ans;
        int a[26] = {0};
        int b[26] = {0};
        for (int k = 0; k < plen; k++) {
            b[p[k] - 'a']++;
        }
        int i = 0;
        for (int j = plen - 1; j < slen; j++) {
            if (i == 0) {
                for (int k = 0; k <= j; k++) {
                    a[s[k] - 'a']++;
                }
                if (check(a, b) == true) {
                    ans.push_back(i);
                }
            } else {
                a[s[j] - 'a']++;
                a[s[i - 1] - 'a']--;
                if (check(a, b) == true) {
                    ans.push_back(i);
                }
            }
            i++;
        }
        return ans;
    }

    // 辅助函数：判断两个计数数组是否相等
    bool check(int a[], int b[]) {
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    }
};
```
官方题解直接用 vector 来定义 a 和 b，然后直接用 a == b 来判断是否相等，不额外写，代码如下：  
```c++
class Solution {
   public:
    // 函数功能：在字符串s中寻找所有是字符串p的字母异位词的子串，返回这些子串的起始索引
    vector<int> findAnagrams(string s, string p) {
        int sLen = s.size(), pLen = p.size();

        // 边界条件：如果s的长度小于p，不可能存在异位词，直接返回空数组
        if (sLen < pLen) {
            return vector<int>();
        }

        vector<int> ans;            // 存储结果的索引数组
        vector<int> sCount(26, 0);  // 用于记录s中当前窗口内各字母的出现次数（26个小写字母）
        vector<int> pCount(26, 0);  // 用于记录p中各字母的出现次数

        // 初始化：统计p的字母频率和s中第一个窗口（长度为pLen）的字母频率
        for (int i = 0; i < pLen; ++i) {
            ++sCount[s[i] - 'a'];  // 将字符转为0-25的索引（'a'-'a'=0, 'b'-'a'=1, ..., 'z'-'a'=25）
            ++pCount[p[i] - 'a'];
        }

        // 检查初始窗口是否与p是异位词，如果是则记录起始索引0
        if (sCount == pCount) {
            ans.emplace_back(0);  // emplace_back比push_back更高效，直接在容器中构造元素
        }

        // 滑动窗口：从左到右移动窗口，每次移动一位
        for (int i = 0; i < sLen - pLen; ++i) {
            // 移除窗口最左侧的字符（将其计数减1）
            --sCount[s[i] - 'a'];
            // 添加窗口右侧新进入的字符（将其计数加1）
            ++sCount[s[i + pLen] - 'a'];

            // 检查当前窗口是否与p是异位词，如果是则记录起始索引i+1
            if (sCount == pCount) {
                ans.emplace_back(i + 1);
            }
        }

        return ans;
    }
};
```


参考：[代码随想录](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html)