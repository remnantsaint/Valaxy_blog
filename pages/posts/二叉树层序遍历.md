---
layout: post
title: 二叉树层序遍历
date: 2025-08-26 16:58:59
updated: 2025-08-27
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 102. 二叉树的层序遍历
  [题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)  
  题意：给二叉树的根节点，返回节点值的层序遍历，空结点返回 null  
  思路：  
  层序遍历一个二叉树，就是从左到右一层一层的遍历，需要借用队列来辅助实现  

  队列先进先出，符合一层一层遍历的逻辑，而用栈先进后厨适合模拟深度优先遍历也就是递归的逻辑  

  层序遍历的方式就是图论中的广度优先遍历，只不过我们应用在二叉树上  

  也就是先入一个根节点，然后把这个根节点的左孩子和右孩子依次入队列，然后再把队列头结点输出，直到队列为空  

  代码如下：  
```c++
class Solution {
   public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```
  因为本题要求是逐层输出，所以要创建二维数组，用for来模拟每一层  

## 107. 二叉树的层序遍历 Ⅱ
  [题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)  
  题意：返回自底向上的层序遍历  
  思路：反转一下 102 题的结果数组  
  代码如下：  
```c++
class Solution {
   public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end());  // 在这里反转一下数组即可
        return result;
    }
};
```

## 199. 二叉树的右视图
  [题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/description/)  
  题意：给一个根节点，想象站在二叉树的右侧，按照从顶部到底部的顺序，返回从右侧能看到的所有结点值  
  思路：每一层看到一个结点，也就是说每一层最后面入队的就能看到，层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了  
  代码如下：  
```c++
class Solution {
   public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == (size - 1))
                    result.push_back(node->val);  // 将每一层的最后元素放入result数组中
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## 637. 二叉树的层平均值
[题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)  
题意：  
思路：  

























  参考：[代码随想录](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)