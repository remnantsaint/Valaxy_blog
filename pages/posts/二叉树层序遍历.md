---
layout: post
title: 二叉树层序遍历
date: 2025-08-26 16:58:59
updated: 2025-09-3
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 102. 二叉树的层序遍历
  [题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)  
  题意：给二叉树的根节点，返回节点值的层序遍历，空结点返回 null  
  思路：  
  层序遍历一个二叉树，就是从左到右一层一层的遍历，需要借用队列来辅助实现  

  队列先进先出，符合一层一层遍历的逻辑，而用栈先进后厨适合模拟深度优先遍历也就是递归的逻辑  

  层序遍历的方式就是图论中的广度优先遍历，只不过我们应用在二叉树上  

  也就是先入一个根节点，然后把这个根节点的左孩子和右孩子依次入队列，然后再把队列头结点输出，直到队列为空  

  代码如下：  
```c++
class Solution {
   public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```
  因为本题要求是逐层输出，所以要创建二维数组，用for来模拟每一层  

## 107. 二叉树的层序遍历 Ⅱ
  [题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)  
  题意：返回自底向上的层序遍历  
  思路：反转一下 102 题的结果数组  
  代码如下：  
```c++
class Solution {
   public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end());  // 在这里反转一下数组即可
        return result;
    }
};
```

## 199. 二叉树的右视图
  [题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/description/)  
  题意：给一个根节点，想象站在二叉树的右侧，按照从顶部到底部的顺序，返回从右侧能看到的所有结点值  
  思路：每一层看到一个结点，也就是说每一层最后面入队的就能看到，层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了  
  代码如下：  
```c++
class Solution {
   public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == (size - 1))
                    result.push_back(node->val);  // 将每一层的最后元素放入result数组中
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## 637. 二叉树的层平均值
[题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)  
题意：给一个非空二叉树的根节点 root，以数组形式返回每一层节点的平均值  
思路：double 类型，层次遍历中，遍历完每层，记录一下每层的平均值  
代码如下：  
```c++
class Solution {
   public:
    vector<double> averageOfLevels(TreeNode* root){
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<double> result;
        while (!que.empty()) {
            int size = que.size();
            double res = 0;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                res += node->val;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }

            result.push_back(res / size);
        }
        return result;
    }
};
```
## 429. N叉树的层序遍历
[题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)  
题意：给一个 N 叉树，返回其节点值的层序遍历  
思路：可知由 children[i] 来访问孩子，和二叉树差不多，只是在 if 环节循环 N 次  
代码如下：
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;
    Node() {}
    Node(int _val) {
        val = _val;
    }
    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*>que;
        if(root != nullptr) que.push(root);
        vector<vector<int>> result;
        while(!que.empty()){
            int size = que.size();
            vector<int> res;
            for(int i = 0; i < size; i++){
                Node* nd = que.front();
                que.pop();
                res.push_back(nd->val);
                for(int j = 0; j < nd->children.size(); j++){
                    if(nd->children[j]) que.push(nd->children[j]);
                }
            }
            result.push_back(res);
        }
        return result;
    }
};
```
## 515. 在每个树行中找最大值
[题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)  
题意：给一颗二叉树，找出该二叉树每一层的最大值  
思路：层序遍历的同时找最大值，很简单  
代码如下：  
```c++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int res = INT_MIN;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                res = max(res, node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }

            result.push_back(res);
        }
        return result;
    }
};
```
## 116. 填充每个节点的下一个右侧节点指针
[题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)  
  题意：  
给一个完美二叉树，其所有叶子节点都在同一侧，每个父节点都有两个子结点，二叉树定义如下：  
```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```
填充它的每个 next 指针，让这个指针指向其下一个右侧节点（同一层的右侧），如果找不到下一个右侧节点，则将 next 指针指向 nullptr  
初始所有 next 都指向 nullptr  

  思路：  
  层序遍历，判断有没有右侧节点，有的话就指向，没有就指向 nullptr  

代码如下：  
```c++
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; // 本层前一个节点next指向本节点
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            node->next = nullptr; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```
## 117. 填充每个节点的下一个右侧节点指针 Ⅱ
[题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)  
题意：在上一题的基础上，给的是一颗普通二叉树，不是满二叉树  
思路：在层次遍历上完全一样，代码不变  

## 104. 二叉树的最大深度
[题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)  
题意：给一个二叉树，返回最大深度  
### 方法一（迭代
思路：层序遍历，同时记录遍历了多少层  
代码如下：  
```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```
### 方法二（后序递归
思路：  
用后序时，求的是高度，指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）  
自底向上  
而根节点的高度就是深度  
代码如下：  
```c++
class Solution {
public:
    int getdepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};
```
### 方法三（前序递归
思路：  
用前序时，直接求深度，指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）  
从上到下  
代码如下：  
```c++
class Solution {
public:
    int result;
    void getdepth(TreeNode* node, int depth) {
        // 每访问一个节点，就检查当前深度是否是目前见过的最大值
        result = depth > result ? depth : result; // 中

        // 如果是叶子节点，直接返回（因为已经更新过深度了）
        if (node->left == NULL && node->right == NULL) return ;

        // 递归遍历
        if (node->left) { // 左
            depth++;    // 深度+1
            getdepth(node->left, depth);
            depth--;    // 回溯，深度-1
            // 可以直接写成 getdepth(node->left, depth + 1); 就不用回溯了
        }
        if (node->right) { // 右
            depth++;    // 深度+1
            getdepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == NULL) return result;
        getdepth(root, 1);
        return result;
    }
};
```

## 111. 二叉树的最小深度
[题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)  
题意：和最大深度相对，找到最小深度（有叶节点的最小深度）  
### 方法一（迭代
思路：层序遍历，过程中，如果有结点的左右孩子都为空，就证明遍历到最小深度了  
代码如下：  
```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```
### 方法二（后序递归
```c++
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```
### 方法三（前序递归
```c++
class Solution {
private:
    int result;
    void getdepth(TreeNode* node, int depth) {
        // 函数递归终止条件
        if (node == nullptr) {
            return;
        }
        // 中，处理逻辑：判断是不是叶子结点
        if (node -> left == nullptr && node->right == nullptr) {
            result = min(result, depth);
        }
        if (node->left) { // 左
            getdepth(node->left, depth + 1);
        }
        if (node->right) { // 右
            getdepth(node->right, depth + 1);
        }
        return ;
    }

public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        result = INT_MAX;
        getdepth(root, 1);
        return result;
    }
};
```



















  参考：[代码随想录](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)