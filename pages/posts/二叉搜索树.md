---
layout: post
title: 二叉搜索树
date: 2025-09-10 15:48:53
updated: 2025-09-10
time_warning: true 
cover: 
top: 
tags: 
 - 二叉搜索树
 - 搜索树
categories:
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 700. 二叉搜索树中的搜索
[题目链接](https://leetcode.cn/problems/search-in-a-binary-search-tree/)  
  题意：给定二叉搜索树（BST）的根节点 root 和一个整数 val ，需要在 BST 中找到节点值等于 val 的节点，返回以该节点为根的子树，如果节点不存在，则返回 null  
  
  二叉搜索树是一个有序树：
* 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
* 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
* 它的左右子树也分别为二叉搜索树
  
这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样  

### 方法一（递归
  思路：1.确定递归函数的参数和返回值；2.确定终止条件；3.确定单层递归的逻辑  
  
  因为二叉树是有序的，所以可以有方向的去搜索
  
  代码如下：  
```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr || root->val == val){
            return root;
        }
        TreeNode* result = NULL;
        if(root->val > val) result = searchBST(root->left, val);
        if(root->val < val) result = searchBST(root->right, val);
        return result;
    }
};
```
### 方法二（迭代
  思路：  
  提到二叉树的迭代法，就要想到用栈来模拟深度遍历，用队里来模拟广度遍历
  
  对于二叉搜索树就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不适用辅助栈或者队列就写出迭代法
  
  对于二叉搜索树，不需要回溯的过程，因为节点的有序性帮我们确定了搜索的方向  
  
  所以迭代法非常简单
  
  代码如下：
```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

## 98. 验证二叉搜索树
[题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)  
题意：给一颗二叉树的根节点，判断其是否是一个有效的二叉搜索树
思路：！！在中序遍历下，输出的二叉搜索树的数值是有序序列  
中序递归所有节点，存下来后判断是否递增，也不能有重复元素  
```c++
class Solution {
    vector<int> vec;
    void traversal(TreeNode* root){
        if(root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val);
        traversal(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear();
        traversal(root);
        for(int i = 1; i < vec.size(); i++){
            if(vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```
  
  迭代法就是用栈模拟中序遍历，并多用一个记录前节点的 pre 指针，代码如下：  
```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // 左
            } else {
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur->right;               // 右
            }
        }
        return true;
    }
};
```
  
## 530. 二叉搜索树的最小绝对差
[题目链接](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)  
题意：给一颗所有节点为非负值的二叉搜索树，计算树中任意两节点的差的绝对值的最小值
思路：因为二叉搜索树的中序遍历是一个递增序列，所以边遍历的同时计算最小值就行了  
代码如下：  
```c++
class Solution {
private:
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val); // 将二叉搜索树转换为有序数组
        traversal(root->right);
    }
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i - 1]);
        }
        return result;
    }
};
```
迭代法和递归法都可以在上一题的基础上稍微修改得到  

## 501. 二叉搜索树中的众数
[题目链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)  
题意：找出二叉搜索树中的所有众数（可不同），不使用额外空间（假设由递归产生的隐式调用栈的开销不被计算在内  
### 递归
#### 二叉树
如果不是二叉搜索树，而是普通的二叉树，那么就遍历树，然后用 map 统计频率，最后把频率排个序取前面的高频元素集合  
代码如下：
```c++
class Solution {
private:
    void searchBST(TreeNode* cur, unordered_map<int, int>& mp) { // 前序遍历
        if (cur == NULL) return;
        mp[cur->val]++; // 统计元素频率
        searchBST(cur->left, mp);
        searchBST(cur->right, mp);
        return;
    }
    bool static cmp(const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second; // 按频率从大到小排序
    }
public:
    vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> mp; // key:元素，value:出现频率
        vector<int> result;
        if (root == NULL) return result;
        searchBST(root, mp);
        vector<pair<int, int>> vec(mp.begin(), mp.end());
        sort(vec.begin(), vec.end(), cmp); // 给频率排个序
        result.push_back(vec[0].first);
        for (int i = 1; i < vec.size(); i++) {
            // 取最高的放到result数组中
            if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
            else break;
        }
        return result;
    }
};
```
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  参考：[代码随想录](https://www.programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  
