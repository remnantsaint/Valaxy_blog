---
layout: post
title: 滑动窗口最大值
date: 2025-08-22 13:26:50
updated: 2025-08-22
time_warning: true 
cover: 
top: 
tags: 
 - stl
categories: 
 - 算法基础
 - 栈与队列
# author: @Remsait
---
## 239. 滑动窗口最大值
> 解法挺好

[题目链接](https://leetcode.cn/problems/sliding-window-maximum/)  
**题意：**  
给一个整数数组和一个大小为 k 的滑动窗口，滑动窗口每次向右滑动一位，每次输出窗口中的最大值  
**思路：**  
使用单调队列，由双端队列实现  
**队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的**  
定义单调队列`pop`操作：如果窗口移除的元素等于单调队列的出口元素，那么队列弹出元素，否则不做任何操作  
`push`操作：如果 push 的元素大于入口元素，那么将队列入口元素弹出，直到 push 的元素数值小于等于队列入口元素的数值为止，如果小于入口元素，就直接放进去（也就是说单调队列进大数就后面全出去，进小数就直接放进去）  
代码如下：  
```c++
class Solution {
   public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;  // 存放值，保持单调递减
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            // 1. 窗口滑出元素时，如果它正好等于队头，就把它弹出
            if (i >= k && !dq.empty() && dq.front() == nums[i - k]) {
                dq.pop_front();
            }
            // 2. 保持队列单调递减，队尾小于当前值就弹出
            while (!dq.empty() && dq.back() < nums[i]) {
                dq.pop_back();
            }
            // 3. 插入当前值
            dq.push_back(nums[i]);
            // 4. 窗口形成后，队头就是最大值
            if (i >= k - 1) {
                res.push_back(dq.front());
            }
        }
        return res;
    }
};
```

## 347. 前 K 个高频元素
[题目链接](https://leetcode.cn/problems/top-k-frequent-elements/description/)  
**题意：**  
给一个整数数组和一个整数 k ，返回其中出现频率前 k 高的元素，可以按任意顺序返回答案  
算法的时间复杂度必须优于 O(n log n)  
**思路：**  
使用优先队列和 map ，维护 k 个最高频率的元素就完事了（用小根堆，队列从小到大）  
代码如下：  
```c++
class Solution {
   public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1. 统计频率
        unordered_map<int, int> freq;
        for (int x : nums) {
            freq[x]++;
        }
        // 2. 定义小根堆：pair<频率, 数字>
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // 3. 遍历map，维护大小为k的小根堆
        for (auto& [num, count] : freq) {
            pq.push({count, num});
            if (pq.size() > k) {
                pq.pop();  // 保证堆里始终只有k个最大频率
            }
        }
        // 4. 取出结果
        vector<int> res;
        while (!pq.empty()) {
            res.push_back(pq.top().second);
            pq.pop();
        }
        return res;
    }
};
```
下面是用结构体来定义小根堆的写法：  
```c++
class Solution {
   public:
    // 小顶堆
    class mycomparison {
       public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map;  // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }
        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
        // 用固定大小为k的小顶堆，扫面所有频率的数值
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) {  // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }
        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;
    }
};
```