---
categories: 
  - 人工智能
  - 机器学习
cover: 
date: 2024-09-06 10:52:42
image: 
layout: post
tags: 机器学习
time_warning: true
title: Logistic回归 
top: 
---

## Logistic回归概念
### 概述
&emsp; Logistic回归又叫逻辑回归，实际上是用来做分类，主要思想是根据现有数据对分类边界线建立回归公式，以此进行分类

### Sigmoid函数
#### 回归概念
&emsp; 假设现在有一些数据点，我们用一条直线对这些点进行拟合（这条直线称为最佳拟合直线），这个拟合过程就叫做回归。进而可以得到对这些点的拟合直线方程，以下是根据这个回归方程如何进行分类。

#### 二值型输出分类函数
&emsp; 我们需要一个能接受所有输入，然后预测出类别的函数，例如在两个类的情况下，函数只输出0 or 1，这种函数称为`海维赛德阶跃函数`，或者直接称为`单位阶跃函数`。  
&emsp; 然而这个函数的问题在于：该函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程有时很难处理。而`Sigmoid函数`在数学上更容易处理，具体公式如下：
$\sigma (z)=\frac{1}{1+e^{-z} }$   
&emsp; 下图给出了Sigmoid函数在不同坐标尺度下的两条曲线图。当x为0时，Sigmoid函数值为 0.5，随着 x 的增大，对应的 Sigmoid 值将逼近于 1；而随着 x 的减小，Sigmoid 的值将逼近于0，如果横坐标刻度足够大，Sigmoid 函数看起来很像一个阶跃函数。
![](https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/%E9%98%B6%E8%B7%83.png)  
&emsp; 为了实现 Logistic 回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有结果的值相加，将这个总和带入 Sigmoid 函数中，得到一个范围在 0~1 之间的数值。任何大于 0.5 的数据被分入 1 类，小于 0.5 被分入 0 类，因此 Logistic 回归也是一种概率估计。

### 基于最优化方法的回归系数确定
&emsp; 将 Sigmoid 函数的输入记为 z ，由下面的公式得到：  
$$z = w_{0}x_{0} + w_{1}x_{1} + ......+w_{n}x_n$$  
&emsp; 如果采用向量的写法，上述公式可以写成$z=w^{T}x$，它表示将这两个数值向量对应的元素相乘然后全部加起来得到 z 值。其中向量 x 是分类器的输入数据，向量 w 是我们要找的最佳参数（系数），从而使得分类器尽可能地精确。为了寻找该最佳参数，需要用到最优化理论的一些知识，这里我们使用——梯度上升法（Gradient Ascent）。

### 梯度上升法
#### 梯度的介绍
- 向量 = 值 + 方向
- 梯度 = 向量
- 梯度 = 梯度值 + 梯度方向

#### 梯度上升法的思想
&emsp; 要找到某函数的最大值，最好的方法是沿着该函数的梯度方向探寻。将梯度记为 ▽ ，则函数 f(x,y) 的梯度由下式表示：
$$\nabla f(x,y) = \begin{bmatrix}\frac{\partial f(x,y)}{\partial x} 
 \\
\frac{\partial f(x,y)}{\partial y}
\end{bmatrix}$$   
&emsp; 这个梯度意味着要沿 x 的方向移动$\frac{\partial f(x,y)}{\partial x}$，沿 y 的方向移动$\frac{\partial f(x,y)}{\partial y}$。其中，函数 f(x,y) 必须要在待计算的点上由定义并且可微。    
![](https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/tidushangsheng.png)
&emsp; 梯度上升算法到每个点后都会重新估计移动的方向。从 P0 开始，计算完该点的梯度，函数就根据梯度移动到下一点 P1 。在 P1 点，梯度再次被计算，并沿着新的梯度方向移动到 P2 ，如此循环迭代，直到满足停止条件。迭代过程中，梯度算子总是保证我们能选取到最佳的移动方向，即函数值增长最快的方向。这里所说的是移动方向，未提到移动量的大小，该量值称为步长，记作 α。用向量来表示的话，梯度上升算法的迭代公式如下   
$w := w + α\nabla wf(w)$   
&emsp; 该公式将一直被迭代执行，直到达到某个停止条件为止，比如迭代次数达到某个指定值或者算法达到某个可以允许的误差范围。   
相关概念：
```text
例如: y = w0 + w1x1 + w2x2 + ... + wnxn
梯度: 参考上图的例子，二维图像，x方向代表第一个系数，也就是 w1，y方向代表第二个系数也就是 w2，这样的向量就是梯度。
α: 上面的梯度算法的迭代公式中的阿尔法，这个代表的是移动步长（step length）。移动步长会影响最终结果的拟合程度，最好的方法就是随着迭代次数更改移动步长。
步长通俗的理解，100米，如果我一步走10米，我需要走10步；如果一步走20米，我只需要走5步。这里的一步走多少米就是步长的意思。
▽f(w): 代表沿着梯度变化的方向。
```
> 如果目标函数是损失函数，就叫梯度下降算法。如果目标函数是似然函数，就叫梯度上升算法。
> 对应的公式可以写成$w := w - α\nabla wf(w)$  

#### 局部最优现象 (Local Optima)
&emsp; 我们想最小化损失函数，就是让损失函数的值尽可能的低，然是梯度下降的最终点并非是全局最小点，也可能是一个局部最小点。
&emsp; 所以这个算法将会在很大的程度上被初始点的选择影响而陷入局部最小点。

## Logistic回归原理
### 回归工作原理
```text
每个回归系数初始化为 1
重复 R 次:
    计算整个数据集的梯度
    使用 步长 x 梯度 更新回归系数的向量
返回回归系数
```

#### 回归开发流程
```text
收集数据: 采用任意方法收集数据
准备数据: 由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。
分析数据: 采用任意方法对数据进行分析。
训练算法: 大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。
测试算法: 一旦训练步骤完成，分类将会很快。
使用算法: 首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数就可以对这些数值进行简单的回归计算，判定它们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。
```

#### Logistic回归算法特点
- 优点：计算代价不高，易于理解和实现
- 缺点：容易欠拟合，分类精度可能不高
- 适用数据类型：数值型和标称型数据

## Todo
项目实战


















## Reference
<https://github.com/remnantsaint/ailearning/blob/master/docs/ml/5.md>
