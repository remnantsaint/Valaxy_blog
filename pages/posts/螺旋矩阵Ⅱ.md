---
layout: post
title: 螺旋矩阵Ⅱ
date: 2025-08-03 14:15:31
cover: 
top: 
tags: 
 - 数组
categories: 
 - 算法基础
 - 数组
# author: @Remsait
---
## 59. 螺旋矩阵Ⅱ
[题目链接](https://leetcode.cn/problems/spiral-matrix-ii/description/)  
给定一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵  
**本题单纯是模拟器，十分考察对代码的掌控能力**  
求解本题依然遵循**循环不变量**原则  
模拟顺时针画矩阵过程：  
* 填充上行从左到右
* 填充右列从上到下
* 填充下行从右到左
* 填充左列从下到上

由外圈向内圈画下去，但是会发现边界条件非常多，在每一个循环中，如此多的边界条件，如果不按照固定规则来遍历，就很容易出错  
一圈下来，要画四条边，每画一条边都要坚持一致的左闭右开或者左开右闭原则  
代码如下：  
```c++
class Solution {
   public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));  // 使用vector定义一个二维数组
        int startx = 0, starty = 0;                     // 定义每循环一个圈的起始位置
        int loop = n / 2;
        // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2;
        // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1;       // 用来给矩阵中每一个空格赋值
        int offset = n - 1;  // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i, j;
        while (loop--) {
            i = startx;
            j = starty;
            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            // !!offset 是前两边的边界，后两个边的边界要用startx和starty
            for (j; j < offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }
            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0,
            // 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;
            // offset 控制每一圈里每一条边遍历的长度
            offset--;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```
简化一点，只维护四个边界的话，代码如下：   
```c++
class Solution {
   public:
    vector<vector<int>> generateMatrix(int n) {
        int t = 0;      // top
        int b = n - 1;  // bottom
        int l = 0;      // left
        int r = n - 1;  // right
        vector<vector<int>> ans(n, vector<int>(n));
        int k = 1;
        while (k <= n * n) {
            for (int i = l; i <= r; ++i, ++k) ans[t][i] = k;
            ++t;
            for (int i = t; i <= b; ++i, ++k) ans[i][r] = k;
            --r;
            for (int i = r; i >= l; --i, ++k) ans[b][i] = k;
            --b;
            for (int i = b; i >= t; --i, ++k) ans[i][l] = k;
            ++l;
        }
        return ans;
    }
};
```
## 54. 螺旋矩阵
[题目链接](https://leetcode.cn/problems/spiral-matrix/description/)  
同样是缩圈遍历，维护边界很重要，开始就把四个边界定义出来，每模拟一条边就修改一下边界  
注意判断单行或单列，防止重复遍历  
代码如下：
```c++
class Solution {
   public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
    	// 注意，若是空矩阵，matrix.size()会报错，所以应该开头就判断是否为空
        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        // !!!维护以上四个边界，就方便循环遍历了
        vector<int> result;
        while (top <= bottom && left <= right) {
            // 右
            for (int j = left; j <= right; j++) {
                result.push_back(matrix[top][j]);
            }
            top++;
            // 下
            for (int i = top; i <= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--;
            // 左
            // if判断防止单行或单列重复遍历
            if (top <= bottom) {
                for (int j = right; j >= left; j--) {
                    result.push_back(matrix[bottom][j]);
                }
                bottom--;
            }
            // 上
            // 同理
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result.push_back(matrix[i][left]);
                }
                left++;
            }
        }
        return result;
    }
};
```








参考：[代码随想录](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  