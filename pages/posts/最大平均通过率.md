---
layout: post
title: 最大平均通过率
date: 2025-09-01 17:08:48
updated: 2025-09-01
time_warning: true 
cover: 
top: 
tags:
 - 优先队列
categories: 
 - 题解
 - 优先队列
# author: @Remsait
---
## 1792. 最大平均通过率
[题目链接](https://leetcode.cn/problems/maximum-average-pass-ratio/description/?envType=daily-question&envId=2025-09-01)  
  **题意：**
  
  给一个二维数组`classes`，其中 $classes[i]=[pass_i, total_i]$ ，表示提前知道了第 i 个班级总共有 $total_i$ 个学生，其中只有 $pass_i$ 个学生可以通过考试  
  
  给一个整数 extraStudents ，表示有额外这么些学生，一定能通过期末考试，需要给这些学生安排一个班级，使得所有班级的**平均通过率**最大，平均通过率等于考试人数除以所有人数
  
  **思路：**
  
  贪心思路，越往上加人，通过率的变化越小，所以每次给通过率最小（增益最大）的班级加一人，然后重新排序
  
  用一个结构体来存班级能通过人数和总人数，然后写一个比较函数，比较两个班级添加一人后通过率增长的大小，最后用这个结构体创造一个优先队列，自动排序添加一人后哪个班级的通过率最小，就给这个班级加人数  
  
  数学公式化简一下
  
  重点是结构体和排序函数的写法：
  给我一下化简前和化简后的latex数学公式，然后给我
  代码如下：
```c++
#include <bits/stdc++.h>
using namespace std;

struct Ratio {
    int pass, total;
};

// 比较器：谁的增益更大，谁优先
struct Compare {
    bool operator()(const Ratio& a, const Ratio& b) const {
        return (long long)(b.total + 1) * b.total * (a.total - a.pass)
             < (long long)(a.total + 1) * a.total * (b.total - b.pass);
    }
};

class Solution {
public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        priority_queue<Ratio, vector<Ratio>, Compare> q;

        // 初始化队列
        for (auto &c : classes) {
            q.push({c[0], c[1]});
        }

        // 分配额外学生
        for (int i = 0; i < extraStudents; i++) {
            auto cur = q.top(); 
            q.pop();
            q.push({cur.pass + 1, cur.total + 1});
        }

        // 计算结果
        double res = 0;
        while (!q.empty()) {
            auto cur = q.top(); 
            q.pop();
            res += 1.0 * cur.pass / cur.total;
        }
        return res / classes.size();
    }
};

``` 
  记住比较器的写法  

  ！！！注意：  
  
  auto x = xxx; 时，只要后面是明确的类型，这样 x 就能被 auto 自动创建和后面一样的类型  
  
  在循环中  
  auto x : v  （不加 & ，拷贝一份，不影响原值，多占空间  
  auto &x : v （加 & ，引用原值，不拷贝，会改变原值  
  const auto &x : v （加 const，引用原值，但是只读，改变时会报错，不拷贝  
  所以，有时即使不改变原值，也可以加上 & ，因为可以少占用空间  
