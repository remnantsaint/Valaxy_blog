---
layout: post
title: 哈希表理论基础
date: 2025-08-09 09:08:16
cover: 
top: 
tags: 
 - 哈希表
categories: 
 - 算法基础
 - 哈希表
# author: @Remsait
---
## 理论基础
### 哈希表
什么是哈希表？   
哈希表是根据关键码的值而直接进行访问的数据结构  
简单来说数组就是哈希表，用处是**用来快速判断一个元素是否出现在集合里**  
例如要查找一个数是否在数组里，枚举的时间复杂度是 O(1)，而哈希表只需要 O(1)  
将数映射到哈希表上就涉及到了 **哈希函数**  
### 哈希函数
哈希函数，把数直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这个数是否在数组内了。  
如果存的不是整型数而是其他类型，可以用 hashCode 函数来通过特征编码方式转化为数值，再通过`index = hashCode(name) % tableSize`来映射  
如果索引大于哈希表的长度，就应该对其取模，保证在长度内。  
那么如果两个数被映射到同一下标上怎么办？ 下面就用到了哈希碰撞  
### 哈希碰撞
两个数被映射到同一索引下标的位置，这一现象被称作哈希碰撞  
有两种解决办法：拉链法和线性探测法
#### 拉链法
就是在索引处建一个链表，每重复一个数就在后面插入  
应该适当选择哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间
#### 线性探测法
使用线性探测法时，首先要保证 tableSize 大于 dataSize，即数据规模小于哈希表大小，利用哈希表中的空位解决问题  
例如发成哈希碰撞，就把后来者往后移动，直到找到空位就存在那  
### 常见的三种哈希结构
当我们想用哈希法来解决问题时，一般会选用如下三种数据结构  
* 数组
* set（集合）
* map（映射）

#### set（集合）
| 集合                | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
|---------------------|----------|----------|------------------|--------------|----------|----------|
| `std::set`          | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| `std::multiset`     | 红黑树   | 有序     | 是               | 否           | O(log n) | O(log n) |
| `std::unordered_set`| 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以 key 值是有序的，但 key 不可以修改，改动 key 值会导致整棵树的错乱，所以只能删除和增加。  
#### map（映射）
| 映射                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
|----------------------|----------|----------|------------------|--------------|----------|----------|
| `std::map`           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| `std::multimap`      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| `std::unordered_map` | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。  
#### 用法
当我们要用集合来解决哈希问题时，优先使用 unordered_set，因为它的查询和增删效率都是最优的，如果需要集合有序，那就用 set ，如果要求不仅有序还要有重复数据的话，就用 multiset  
再来看 map ，map 时一个 <key , value> 的数据结构，在 map 中对 key 有限制，对 value 是没有限制的，因为 key 的存储方式使用红黑树实现
### 总结
**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**  
哈希法是**牺牲空间换取时间**   



参考：[代码随想录](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8)