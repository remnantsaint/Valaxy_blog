---
layout: post
title: 二叉搜索树的修改与构造
date: 2025-09-13 21:47:44
updated: 2025-09-17
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
 - 搜索树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 701. 二叉搜索树中的插入操作
[题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)  
题意：给定二叉搜索树的根节点 root 和要插入树中的值 value，将值插入二叉搜索树，返回插入后的根节点（可能存在多种有效的插入方式）  
### 递归
思路：  
从根节点往下找，要插入的 x 大于当前结点就往右找，反之同理，到空结点就返回  
搜索树不需要遍历整棵树  
代码如下：  
```c++
class Solution {
public:
    TreeNode* parent;
    void traversal(TreeNode* cur, int val){
        if(cur == NULL){
            TreeNode* node = new TreeNode(val);
            if(val > parent->val) parent->right = node;
            else parent->left = node;
            return;
        }
        parent = cur;
        if(cur->val > val) traversal(cur->left, val);
        if(cur->val < val) traversal(cur->right, val);
        return;
    }
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL){
            root = new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }
};
```
### 迭代
思路：  
迭代遍历过程中，需要记录一下当前遍历的结点的父节点，这样才能做插入结点的操作  
代码如下：  
```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        TreeNode* cur = root;
        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点
        while (cur != NULL) { // 跟链表一样
            parent = cur;
            if (cur->val > val) cur = cur->left;
            else cur = cur->right;
        }
        TreeNode* node = new TreeNode(val);
        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值
        else parent->right = node;
        return root;
    }
};
```
## 450. 删除二叉搜索树中的节点
[题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)  
题意：给一个二叉搜索树的根节点 root 以及一个值 key ，删除二叉搜索树中 key 对应的节点，并保证二叉搜索树的性质不变  
### 递归
思路：  
  删除要比增加节点复杂得多  
  删除节点有以下五种情况：  
* 第一种 没找到删除的节点，遍历到空节点直接返回
* 找到删除的节点：
	* 第二种：左右孩子都为空（叶子节点），直接删除节点，返回 NULL 为根节点
	* 第三种：左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
	* 第四种：左孩子不空，右孩子为空，删除节点，左孩子补位，返回左孩子为根节点
	* 第五种：左右都不空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点

  第五种稍微有点难理解，可以理解为删除节点的左孩子一定比右子树的所有节点小，所以把整棵左子树接到右子树的最小节点上  
  代码如下：
```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return root; // 第一种情况
        if(root->val == key){
            // 第二种左右都为空
            if(root->left == nullptr && root->right == nullptr){
                delete root;
                return nullptr;
            }
            // 第三种，左空右不空，右孩子补位
            else if(root->left == nullptr && root->right != nullptr){
                auto retNode = root->right;
                delete root;
                return retNode;
            }
            // 第四种，右空左不空，左孩子补位
            else if(root->left != nullptr && root->right == nullptr){
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            // 第五种，都不空，左子树接右子树的最小节点的左孩子上
            else {
                TreeNode* cur = root->right;
                while(cur->left != nullptr){
                    cur = cur->left;
                }
                cur->left = root->left;
                TreeNode* tmp = root;
                root = root->right;
                delete tmp;
                return root;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left, key);
        if(root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```
### 迭代法
```c++
class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```
  在递归法和迭代法中，第五种情况写的代码包括了第三种情况，所以第三种情况删掉也没问题  
  
## 669. 修剪二叉搜索树
[题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)  
题意：给定一个二叉搜索树，同时给定最小边界 L 和最大边界 R，通过修剪二叉搜索树，是的所有的值在 [L, R] 中，可能需要改变树的根节点，所以结果应该返回修剪好的二叉搜索树的新的根节点  












## Reference
 - [代码随想录](https://programmercarl.com/)