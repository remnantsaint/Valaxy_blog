---
layout: post
title: 二叉搜索树的修改与构造
date: 2025-09-13 21:47:44
updated: 2025-09-13
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
 - 搜索树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 701. 二叉搜索树中的插入操作
[题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)  
题意：给定二叉搜索树的根节点 root 和要插入树中的值 value，将值插入二叉搜索树，返回插入后的根节点（可能存在多种有效的插入方式）  
### 递归
思路：  
从根节点往下找，要插入的 x 大于当前结点就往右找，反之同理，到空结点就返回  
搜索树不需要遍历整棵树  
代码如下：  
```c++
class Solution {
public:
    TreeNode* parent;
    void traversal(TreeNode* cur, int val){
        if(cur == NULL){
            TreeNode* node = new TreeNode(val);
            if(val > parent->val) parent->right = node;
            else parent->left = node;
            return;
        }
        parent = cur;
        if(cur->val > val) traversal(cur->left, val);
        if(cur->val < val) traversal(cur->right, val);
        return;
    }
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL){
            root = new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }
};
```
### 迭代
思路：  
迭代遍历过程中，需要记录一下当前遍历的结点的父节点，这样才能做插入结点的操作  
代码如下：  
```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        TreeNode* cur = root;
        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点
        while (cur != NULL) { // 跟链表一样
            parent = cur;
            if (cur->val > val) cur = cur->left;
            else cur = cur->right;
        }
        TreeNode* node = new TreeNode(val);
        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值
        else parent->right = node;
        return root;
    }
};
```
## 450. 删除二叉搜索树中的节点
[题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)  
题意：给一个二叉搜索树的根节点 root 以及一个值 key ，删除二叉搜索树中 key 对应的节点，并保证二叉搜索树的性质不变  















## Reference
 - [代码随想录](https://programmercarl.com/)