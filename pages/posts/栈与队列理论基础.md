---
layout: post
title: 栈与队列理论基础
date: 2025-08-19 10:03:16
updated: 2025-08-19
time_warning: true 
cover: 
top: 
tags: 
 - stl
categories: 
 - 算法基础
 - 栈与队列
# author: @Remsait
---
栈是先进后出，队列是先进先出  
栈和队列是 STL（C++标准库）里的两个数据结构  
C++标准库是有多个版本的，我们使用的是 SGI STL，由Silicon Graphics Computer Systems公司参照 HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，可读性很高  
<br>
栈提供 push 和 pop 等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器（iterator)，不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素  
栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。  
所以 STL 中栈往往不被归类为容器，而被归类为 container adapter(容器适配器)  
STL 中的栈底层实现可以是 vector, deque, list，主要就是数组和链表的底层实现，默认以 deque 双向链表封住一端实现  

| 方法/操作 | 语法 | 功能描述 | 返回值 | 时间复杂度 | 示例代码 |
|-----------|------|----------|--------|------------|----------|
| 包含头文件 | `#include <stack>` | 包含栈的头文件 | - | - | `#include <stack>` |
| 声明栈 | `stack<type> name;` | 创建空栈 | - | O(1) | `stack<int> s;` |
| 拷贝构造 | `stack<type> s2(s1);` | 用s1初始化s2 | - | O(n) | `stack<int> s2(s1);` |
| 入栈 | `push(value)` | 将元素压入栈顶 | void | O(1) | `s.push(10);` |
| 出栈 | `pop()` | 删除栈顶元素 | void | O(1) | `s.pop();` |
| 访问栈顶 | `top()` | 获取栈顶元素 | 元素引用 | O(1) | `int x = s.top();` |
| 判断空栈 | `empty()` | 检查栈是否为空 | bool | O(1) | `if(s.empty())` |
| 获取大小 | `size()` | 返回栈中元素个数 | size_t | O(1) | `int n = s.size();` |
| 交换 | `swap(s2)` | 交换两个栈的内容 | void | O(1) | `s1.swap(s2);` |
| 赋值运算符 | `s1 = s2` | 将s2赋值给s1 | stack& | O(n) | `s1 = s2;` |
| 比较运算符 | `s1 == s2` | 比较两栈是否相等 | bool | O(n) | `if(s1 == s2)` |
| 比较运算符 | `s1 != s2` | 比较两栈是否不等 | bool | O(n) | `if(s1 != s2)` |
| 比较运算符 | `s1 < s2` | 字典序比较 | bool | O(n) | `if(s1 < s2)` |
| 安全访问 | `!s.empty() && s.top()` | 安全获取栈顶 | 元素值 | O(1) | `if(!s.empty()) x = s.top();` |
| 安全出栈 | `!s.empty() && s.pop()` | 安全删除栈顶 | void | O(1) | `if(!s.empty()) s.pop();` |
<br>

SGI STL中队列一样是以deque为缺省情况下的底部结构。  
所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。

| 方法/操作 | 语法 | 功能描述 | 返回值 | 时间复杂度 | 示例代码 |
|-----------|------|----------|--------|------------|----------|
| 包含头文件 | `#include <queue>` | 包含队列的头文件 | - | - | `#include <queue>` |
| 声明队列 | `queue<type> name;` | 创建空队列 | - | O(1) | `queue<int> q;` |
| 拷贝构造 | `queue<type> q2(q1);` | 用q1初始化q2 | - | O(n) | `queue<int> q2(q1);` |
| 入队(尾部) | `push(value)` | 将元素加入队尾 | void | O(1) | `q.push(10);` |
| 出队(头部) | `pop()` | 删除队头元素 | void | O(1) | `q.pop();` |
| 访问队头 | `front()` | 获取队头元素 | 元素引用 | O(1) | `int x = q.front();` |
| 访问队尾 | `back()` | 获取队尾元素 | 元素引用 | O(1) | `int y = q.back();` |
| 判断空队列 | `empty()` | 检查队列是否为空 | bool | O(1) | `if(q.empty())` |
| 获取大小 | `size()` | 返回队列中元素个数 | size_t | O(1) | `int n = q.size();` |
| 交换 | `swap(q2)` | 交换两个队列的内容 | void | O(1) | `q1.swap(q2);` |
| 赋值运算符 | `q1 = q2` | 将q2赋值给q1 | queue& | O(n) | `q1 = q2;` |
| 比较运算符 | `q1 == q2` | 比较两队列是否相等 | bool | O(n) | `if(q1 == q2)` |
| 比较运算符 | `q1 != q2` | 比较两队列是否不等 | bool | O(n) | `if(q1 != q2)` |
| 比较运算符 | `q1 < q2` | 字典序比较 | bool | O(n) | `if(q1 < q2)` |
| 安全访问队头 | `!q.empty() && q.front()` | 安全获取队头 | 元素值 | O(1) | `if(!q.empty()) x = q.front();` |
| 安全访问队尾 | `!q.empty() && q.back()` | 安全获取队尾 | 元素值 | O(1) | `if(!q.empty()) y = q.back();` |
| 安全出队 | `!q.empty() && q.pop()` | 安全删除队头 | void | O(1) | `if(!q.empty()) q.pop();` |









参考：[代码随想录](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)