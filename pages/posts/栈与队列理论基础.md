---
layout: post
title: 栈与队列理论基础
date: 2025-08-19 10:03:16
updated: 2025-08-19
time_warning: true 
cover: 
top: 
tags: 
 - stl
categories: 
 - 算法基础
 - 栈与队列
# author: @Remsait
---
栈是先进后出，队列是先进先出  
栈和队列是 STL（C++标准库）里的两个数据结构  
C++标准库是有多个版本的，我们使用的是 SGI STL，由Silicon Graphics Computer Systems公司参照 HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，可读性很高  
<br>
栈提供 push 和 pop 等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器（iterator)，不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素  
栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。  
所以 STL 中栈往往不被归类为容器，而被归类为 container adapter(容器适配器)  
STL 中的栈底层实现可以是 vector, deque, list，主要就是数组和链表的底层实现，默认以 deque 双向链表封住一端实现  

| 方法/操作 | 语法 | 功能描述 | 返回值 | 时间复杂度 | 示例代码 |
|-----------|------|----------|--------|------------|----------|
| 包含头文件 | `#include <stack>` | 包含栈的头文件 | - | - | `#include <stack>` |
| 声明栈 | `stack<type> name;` | 创建空栈 | - | O(1) | `stack<int> s;` |
| 拷贝构造 | `stack<type> s2(s1);` | 用s1初始化s2 | - | O(n) | `stack<int> s2(s1);` |
| 入栈 | `push(value)` | 将元素压入栈顶 | void | O(1) | `s.push(10);` |
| 出栈 | `pop()` | 删除栈顶元素 | void | O(1) | `s.pop();` |
| 访问栈顶 | `top()` | 获取栈顶元素 | 元素引用 | O(1) | `int x = s.top();` |
| 判断空栈 | `empty()` | 检查栈是否为空 | bool | O(1) | `if(s.empty())` |
| 获取大小 | `size()` | 返回栈中元素个数 | size_t | O(1) | `int n = s.size();` |
| 交换 | `swap(s2)` | 交换两个栈的内容 | void | O(1) | `s1.swap(s2);` |
| 赋值运算符 | `s1 = s2` | 将s2赋值给s1 | stack& | O(n) | `s1 = s2;` |
| 比较运算符 | `s1 == s2` | 比较两栈是否相等 | bool | O(n) | `if(s1 == s2)` |
| 比较运算符 | `s1 != s2` | 比较两栈是否不等 | bool | O(n) | `if(s1 != s2)` |
| 比较运算符 | `s1 < s2` | 字典序比较 | bool | O(n) | `if(s1 < s2)` |
| 安全访问 | `!s.empty() && s.top()` | 安全获取栈顶 | 元素值 | O(1) | `if(!s.empty()) x = s.top();` |
| 安全出栈 | `!s.empty() && s.pop()` | 安全删除栈顶 | void | O(1) | `if(!s.empty()) s.pop();` |
<br>

SGI STL中队列一样是以deque为缺省情况下的底部结构。  
所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。

| 方法/操作 | 语法 | 功能描述 | 返回值 | 时间复杂度 | 示例代码 |
|-----------|------|----------|--------|------------|----------|
| 包含头文件 | `#include <queue>` | 包含队列的头文件 | - | - | `#include <queue>` |
| 声明队列 | `queue<type> name;` | 创建空队列 | - | O(1) | `queue<int> q;` |
| 拷贝构造 | `queue<type> q2(q1);` | 用q1初始化q2 | - | O(n) | `queue<int> q2(q1);` |
| 入队(尾部) | `push(value)` | 将元素加入队尾 | void | O(1) | `q.push(10);` |
| 出队(头部) | `pop()` | 删除队头元素 | void | O(1) | `q.pop();` |
| 访问队头 | `front()` | 获取队头元素 | 元素引用 | O(1) | `int x = q.front();` |
| 访问队尾 | `back()` | 获取队尾元素 | 元素引用 | O(1) | `int y = q.back();` |
| 判断空队列 | `empty()` | 检查队列是否为空 | bool | O(1) | `if(q.empty())` |
| 获取大小 | `size()` | 返回队列中元素个数 | size_t | O(1) | `int n = q.size();` |
| 交换 | `swap(q2)` | 交换两个队列的内容 | void | O(1) | `q1.swap(q2);` |
| 赋值运算符 | `q1 = q2` | 将q2赋值给q1 | queue& | O(n) | `q1 = q2;` |
| 比较运算符 | `q1 == q2` | 比较两队列是否相等 | bool | O(n) | `if(q1 == q2)` |
| 比较运算符 | `q1 != q2` | 比较两队列是否不等 | bool | O(n) | `if(q1 != q2)` |
| 比较运算符 | `q1 < q2` | 字典序比较 | bool | O(n) | `if(q1 < q2)` |
| 安全访问队头 | `!q.empty() && q.front()` | 安全获取队头 | 元素值 | O(1) | `if(!q.empty()) x = q.front();` |
| 安全访问队尾 | `!q.empty() && q.back()` | 安全获取队尾 | 元素值 | O(1) | `if(!q.empty()) y = q.back();` |
| 安全出队 | `!q.empty() && q.pop()` | 安全删除队头 | void | O(1) | `if(!q.empty()) q.pop();` |

<br>

双端队列操作如下：  

| 方法/操作 | 语法 | 功能描述 | 返回值 | 时间复杂度 | 示例代码 |
|-----------|------|----------|--------|------------|----------|
| 包含头文件 | `#include <deque>` | 包含双端队列头文件 | - | - | `#include <deque>` |
| 声明双端队列 | `deque<type> d;` | 创建空双端队列 | - | O(1) | `deque<int> d;` |
| 拷贝构造 | `deque<type> d2(d1);` | 用 d1 初始化 d2 | - | O(n) | `deque<int> d2(d1);` |
| 初始化 | `deque<type> d(n, val);` | 创建含 n 个值为 val 的元素 | - | O(n) | `deque<int> d(5, 10);` |
| 随机访问 | `d[i]` | 获取下标为 i 的元素 | 元素引用 | O(1) | `int x = d[2];` |
| 安全访问 | `d.at(i)` | 获取下标 i 的元素并检查越界 | 元素引用 | O(1) | `int x = d.at(2);` |
| 获取首元素 | `d.front()` | 返回首元素引用 | 元素引用 | O(1) | `int x = d.front();` |
| 获取尾元素 | `d.back()` | 返回尾元素引用 | 元素引用 | O(1) | `int x = d.back();` |
| 插入尾部 | `d.push_back(val)` | 在队尾插入元素 | void | O(1) | `d.push_back(10);` |
| 插入头部 | `d.push_front(val)` | 在队首插入元素 | void | O(1) | `d.push_front(20);` |
| 删除尾部 | `d.pop_back()` | 删除队尾元素 | void | O(1) | `d.pop_back();` |
| 删除头部 | `d.pop_front()` | 删除队首元素 | void | O(1) | `d.pop_front();` |
| 任意位置插入 | `d.insert(pos, val)` | 在 pos 位置插入 val | 迭代器 | O(n) | `d.insert(d.begin()+1, 30);` |
| 任意位置删除 | `d.erase(pos)` | 删除 pos 位置的元素 | 迭代器 | O(n) | `d.erase(d.begin());` |
| 清空 | `d.clear()` | 清空所有元素 | void | O(n) | `d.clear();` |
| 判断空 | `d.empty()` | 检查是否为空 | bool | O(1) | `if(d.empty())` |
| 获取大小 | `d.size()` | 返回元素个数 | size_t | O(1) | `int n = d.size();` |
| 改变大小 | `d.resize(n)` | 调整大小，多余删掉，不足补默认值 | void | O(n) | `d.resize(10);` |
| 交换 | `d1.swap(d2)` | 交换两个 deque 内容 | void | O(1) | `d1.swap(d2);` |
| 赋值运算符 | `d1 = d2` | 将 d2 赋值给 d1 | deque& | O(n) | `d1 = d2;` |
| 比较运算符 | `d1 == d2` | 比较两个 deque 是否相等 | bool | O(n) | `if(d1 == d2)` |
| 比较运算符 | `d1 != d2` | 比较两个 deque 是否不等 | bool | O(n) | `if(d1 != d2)` |
| 比较运算符 | `d1 < d2` | 字典序比较 | bool | O(n) | `if(d1 < d2)` |
| 遍历（迭代器） | `for(auto it=d.begin(); it!=d.end(); ++it)` | 遍历所有元素 | 迭代器 | O(n) | `for(int x : d){...}` |
| 反向遍历 | `rbegin(), rend()` | 从尾到头遍历 | 迭代器 | O(n) | `for(auto it=d.rbegin(); it!=d.rend(); ++it)` |









参考：[代码随想录](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)