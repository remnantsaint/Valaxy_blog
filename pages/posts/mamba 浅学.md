---
layout: post
title: Mamba 浅学
date: 2025-11-24 12:54:59
updated: 2025-11-25
time_warning: true 
cover: 
top: 
tags: 
 - 深度学习
categories: 
 - 深度学习
draft: 
# author: @Remsait
---
## Mamba 动机
  transformer 最大的问题是都采用了注意力机制，而注意力随序列长度的二次增长，简单来说就是需要大量单词查询的时候，transformer的速度可能会非常慢。Mamba 就是致力于解决这个问题，性能更好，而且计算量和序列长度呈线性缩放。
  
### Transformer
  Transformer 把文本的输入看成一个包含多个单词（token）的序列（sequence）。
  
  Transformer 的优点是：无论当前输入是什么，都可以回顾之前看到的所有 Token，而且可以在训练过程中进行并行化运算。
  
  Transformer 的缺点是：在推理过程中，每生成一个新的 token 都需要重新为整个序列计算一个新的 attention map，导致推理性能很慢。对于一个长度为 L 的序列，大约需要 $L^2$ 的计算，如果序列长度增加，计算量会更大。
  
  Transformer 主要包括两个结构，一个是编码器（encoder）用来编码文本输入，一个是解码器（decoder）用来生成输出。
  
  Transformer 性能总结：训练快、推理慢。
  
  目前很火的生成式模型（如 chatGPT）是只使用 decoders 的结构。
  
  Decoder 是由一个 masked self-attention 和一个 feed-forward neural network 构成。其中 self-attention 是 transformer 的核心，可以生成一个 attention map。attention map 是一个权重矩阵，用来存储每两个 token 之间相关性的大小。在训练过程中，这个 attention map 的矩阵是可以并行生成的，因此可以加速训练。
### RNN
  循环神经网络（RNN）是一种基于序列的网络。它在序列的每个时间步都需要两个输入，即时间步 T 的输入和前一个时间步 t-1 的隐藏状态，用来生成下一个隐藏状态并预测输入。
  
  RNN的优点：在生成当前的输出时，RNN只需要考虑当前的输入和上一时刻的隐藏状态。和 Transformer 相比，RNN 不需要重新计算先前所有的隐藏状态。换句话说，RNN 可以快速进行推理，因为它的计算量与序列长度呈线性扩展。理论上，它甚至可以拥有无限长的上下文长度。RNN中，每个隐藏状态都是之前所有隐藏状态的聚合，通常是一个压缩视图。
  
  RNN的缺点：训练不能并行，因为它需要按照时间顺序完成每个步骤。因为在反向传播中，RNN需要计算每个时间步的梯度，并且这些梯度需要沿着时间步依次传播回去。如果同时更新所有时间步的参数，会导致梯度混乱和不稳定，因此不能并行训练。
  
  RNN的性能总结：训练慢、推理快。 
## Mamba 背景
### 状态空间模型（SSM）
#### 什么是状态空间？
  举个例子，假如我们在走迷宫，那么状态空间就是我们在地图中所有可能的状态，包含（在哪里？往哪里走？下一步可能在哪里？）
  
  描述状态的变量，在我们例子中是 X 和 Y 坐标，以及到出口的距离，这些参数可以表示为“状态向量”
#### 什么是状态空间模型？
  SSM 是用于描述这些状态表示的模型，并根据某些输入预测下一个状态可能是什么。
  
  在时刻 t ，SSMs 为：
  * 映射输入序列x(t) -(例如，在迷宫中向左和向下移动)
  * 到隐藏状态表示h(t) -(例如，到出口的距离和x/y坐标)
  * 并推导出预测的输出序列y(t) -(例如，再次向左移动以更快地到达出口)
  
  然而，SSM 不是使用离散序列（如向左移动一次），而是将连续序列作为输入，并预测输出序列。SSM 假设动态系统，例如在 3D 空间中运动的物体，可以通过两个方程从其在时间 t 的状态进行预测
![](https://cloudflare.remsait.com/img/SSM202511241543310.png)
#### 状态方程和输出方程
  状态方程：矩阵 A 和矩阵 B 分别控制着当前状态和输入如何影响状态的变化
  
  输出方程：描述了状态如何转换为输出（通过矩阵 C ），以及输入如何影响输出（通过矩阵 D ）
  
  A、B、C、D 都是科学系的参数，将上述两个方差整合在一起，得到如下结构：
![](https://cloudflare.remsait.com/img/SSM202511241607381.png)
  * 假设我们有一些输入信号 x(t) ，这个信号首先乘以矩阵 B ，矩阵 B 描述了输入如何影响系统。
  * 矩阵 A 和当前状态相乘，矩阵 A 描述了内部状态之间是如何连接的
  * 矩阵 C 和新的状态相乘，矩阵 C 描述了状态时如何转化到输出的
  * 矩阵D提供一个从输入到输出的直接信号，这通常也称为跳跃连接（skip-connection)
  
  SSM 通常被认为是不包含跳跃连接的部分，可以看出矩阵 A、B、C 是 SSM 的核心。由于预期输入是连续的，所以 SSM 的主要表示是连续时间表示。
### 线性状态空间层（LSSL）
  LSSL 的核心思想是把连续时间的 SSM 进行离散化，得到两种离散化的表示（循环形式和卷积形式）
#### 将连续的信号转化为离散的信号
  通常而言，我们的输入是离散的，例如一个文本序列，为了将离散的输入变成 SSM 可用的连续信号，我们使用 零阶保持技术（Zero-order hold technique）
  
  零阶保持技术的原理：我们每次接收到一个离散信号时，都保持它的值，直到我们接收到一个新的离散信号，我们保存该值的时间由一个新的可学习参数表示，称为 步长A。现在我们有了一个连续的信号作为输入，我们可以生成一个连续的输出，并且只根据输入的时间步长对值进行采样，这个采样的值就是我们离散化的输出。也就是说离散的输入成连续，连续的输出成离散。
  
  我们从一个连续的 SSM（函数到函数，x(t) -> y(t)）到一个离散 SSM （序列到序列，$x_k -> y_k$）
![](https://cloudflare.remsait.com/img/SSM202511241635333.png)
#### 循环表示
  在每个时间步长，我们计算当前输入（B$x_k$）如何影响前一个状态（$Ah_{k-1}$），然后计算预测输出（$Ch_k$）
  
  我们可以发现这种循环的 SSM 结构和 RNN 非常的类似。这使得我们可以将RNN的基本方法应用在离散的SSM上，但还需要考虑RNN推理快和训练慢的特性。
#### 卷积表示
  在经典的图像识别任务中，我们使用卷积核来聚集特征，类似的，因为我们处理的是文本而不是图像，所以我们需要一维卷积
  
  将SSM表示为卷积的一个主要好处是，它可以像卷积神经网络(CNN)一样并行训练。然而，由于核大小固定，它们的推理不像RNN那样快速。
#### LSSL 的设计思路
  SSM的三种表示：连续时间、循环、卷积。有了这些表示，我们可以使用一个巧妙的技巧，即根据任务选择一种表示，在推理过程中，我们使用高效的循环表示，这种混合表示就被称为 LSSL。
  
  LSSL的一个重要特性就是 线性时间不变（LTI）
  
  LTI 声明 SSM 参数 A、B、C 对于所有时间步都是固定的，这意味着矩阵 A、B、C 对于 SSM 生成的每个 token 都是相同的，换句话说，无论你给 SSM 什么序列，A、B、C的值都保持不变，我们有一个不感知内容的静态表示。  
### 结构化序列空间模型（S4）
  Mamba 模型是基于 S4 模型构建的。S4 是一个 线性时间不变 的状态空间模型，在每个状态之间，矩阵 A 捕获关于前一个状态的信息以构建新状态，矩阵 A 本质上是用来产生隐藏状态的，那么我们如何构建矩阵 A ，使其保留更多的上下文信息？
  
  这里使用的是 HIPPO ，HIPPO 试图将它迄今为止看到的所有输入信号压缩为一个系数向量，HIPPO 使用矩阵 A 来构建状态标识，可以很好地捕获最近的 token 并衰减旧的 token，其公式可以表示为：$A_{nk} =$
  * $\sqrt{2n+1}\sqrt{2k+1}$（everything below the diagonal
  * $n + 1$（the diagonal
  * 0（everything above the diagonal
  
  假设矩阵 A 的大小是 4*4 ，那么它的 HIPPO Matrix 的表示如下：
  
1 | 0 | 0 | 0
---|---|---|---
1 | 2 | 0 | 0
1 | 3 | 3 | 0
1 | 3 | 5 | 4
  
  使用 HIPPO 构建矩阵 A 比初始化为随机矩阵要好很多，因此，与旧信号（初始 token）相比，它可以更准确地重建较新的信号（最近的 token）
  
  HiPPO矩阵背后的想法是，它产生一个隐藏状态来记忆其历史。从数学的角度而言，它通过跟Legendr多项式的系数来实现这一点，这使得它可以近似之前的所有历史。然后将HiPPO应用于我们之前看到的递归和卷积表示，以处理长程依赖关系。其结果是序列的结构化状态空间(Structured State Space for Sequences, S4)，这是一类可以有效处理长序列的SSM。
  
  S4 主要包括以下三个部分：状态空间模型；HIPPO 用于处理远程依赖；用于创建循环和卷积表示的离散化。
## Mamba 介绍
  Mamba 是一种状态空间模型（SSM）架构，它融合了 RNN 和 CNN 的特点通过递归或卷积操作实现计算成本与序列长度的线性或近线性扩展，改进了 S4 架构。它有时也被称为 S6 或者 selective SSM ，它对 S4 进行了两项重要修改：
  * **选择性扫描算法**：允许模型过滤相关或者不相关的信息，保留必要数据
  * **硬件感知算法**：采用递归扫描而非卷积运算，允许通过并行扫描、核融合和重计算有效地存储中间结果
### Mamba 要解决什么问题
  SSM 和 S4 无法选择性的关注指定的输入。
  
  比如说，在选择性复制任务中，SSM 的目标是复制输入的一部分并按序输出。然而，循环或者卷积 SSM 在这项任务中表现不佳，因为它是线性时间不变的，矩阵A、B、C生成的每个 token 都是相同的，因此 SSM 无法进行内容感知推理，因为它将每个 token 视为固定的 A、B、C 的结果，这是一个问题，我们希望 SSM 对输入进行推理。
  
  或者是要重现在输入中发现的模式，本质上是在实行 one-shot prompting，试图“教”模型在每个“Q”之后提供一个“A"响应。然而，由于 SSM 是时不变的，它无法选择从历史中回忆之前的哪个标记。无论输入是什么，A、B、C都保持不变，这表明我们迄今为止看到的 SSM 都是静态的。
  
  相比之下，Transformer 对这些任务相对容易，因为它们根据输入序列动态改变注意力，它们可以选择性地看或关注序列的不同部分。
  
  SSM 在这些任务上的糟糕表现说明了潜在问题：矩阵A、B、C的静态性质导致了其无法进行内容感知。
### Mamba 的特性一：选择性的保留信息
  SSM 的循环表示创建了一个非常高效的小状态，因为它压缩了整个历史状态。然而与没有压缩历史状态的 Transformer 模型相比，它的性能要差很多。
  
  Mamba 致力于保留一个小的且有用的状态信息，兼顾性能和效率，它通过**选择地将数据压缩到状态中**来实现这一点（当有一个输入句子时，通常会有一些信息，比如标点，没有太多意义。这些无意义的信息就可以被忽略掉。）
  
  为了有选择地压缩信息，我们需要参数依赖于输入，为此，让我们先探究下在训练过程中 SSM 的输入和输出维度
  
  SSM 中输入和输出的维度：B 表示 batchsize，L 表示序列长度，D表示输入张量大小
  
  在结构化状态空间模型（S4）中，矩阵A、B、C与输入无关，因为他们的维数 N 和 D 是静态的，不会改变
  
  相反，Mamba 通过合并输入的序列长度和批次大小，使矩阵 B 和 C ，甚至步长∆依赖于输入，这意味着对于每个输入标记，我们现在有不同的 B 和 C 矩阵，这解决了内容感知问题，这样我们就可以依赖于输入，选择什么保持在隐藏状态，什么要忽略。（Mamba 中矩阵 A 保持不变，因为我们希望状态本身保持静态，但它被影响的方式（通过 B 和 C）是动态的。
  
  更小的步长∆导致忽略特定的单词，而更多地使用前一个上下文，而更大的步长∆则更多地关注输入单词而不是上下文。（**Mamba 通过动态调整步长实现选择性关注**
### Mamba 的特性二：扫描操作
  上述的选择性保留信息也带来了一些问题：由于现在的 B、C、∆ 矩阵是动态的，它们不能使用卷积表示进行计算，因此它假设一个固定的核，我们只能使用递归表示，而失去了卷积提供的并行化。
  
  为了实现并行化，要使用递归计算输出。每个状态是前一个状态（乘以A）加上当前输入（乘以B）的和，这称为扫描操作，可以用 for 循环轻松计算。
![](https://cloudflare.remsait.com/img/Mamba202511251450360.png)
  相比之下，并行化似乎是不可能的，因为只有在我们拥有前一个状态的情况下，每个状态才能计算出来，然而，Mamba 通过并行扫描算法使这成为可能。
![](https://cloudflare.remsait.com/img/Mamba202511251450411.png)
### Mamba 的特性三：硬件感知算法
  GPU 的一个缺点使它们在小型但高效的 SRAM 和大型但略低效率的 DRAM 之间的传输（IO）速度有限，频繁地在 SRAM 和 DRAM 之间复制信息成为瓶颈。
  
  与 Flash Attention 一样，Mamba 试图限制从 DRAM 切换到 SRAM 的次数，反之亦然。它通过核融合来实现这一点，核融合允许模型防止写入中间结果，并持续执行计算，直到完成。
  
  核融合将下列代码融合到一个内核中：用∆离散化步长、选择性扫描算法、与C相乘
  
  硬件感知算法的最后一部分是重计算，中间状态不保存，但对于反向传递计算梯度是必要的，作者在反向传递期间重新计算这些中间状态。虽然这看起来效率不高，但与从相对较慢的 DRAM 读取所有中间状态相比，它的开销要小的多。
  
  现在已经介绍了 Mamba 架构的所有组件，下图是 Mamba 的 Overview：
  * 首先，输入 $X_t$ 通过选择性机制映射得到 $B_t$，∆，$C_t$
  * 然后使用 ∆，用零阶保持技术对 A 和 $B_t$ 进行离散化
  * 离散化后的 B 和输入 $X_t$ 相乘，离散化后的 A 和原始状态 $h_{t-1}$ 相乘，将这两项相加得到新的状态 $h_t$
  * 新状态和 $C_t$ 相乘，得到输出 $y_t$
![](https://cloudflare.remsait.com/img/Mamba202511251514515.png)
### Mamba 基础块的设计
  在 Transformer 中，用 Decoder block 来实现 self-attention。与此类似，在 Mamba 中，也使用 Mamba Block 来实现 selective SSM。
  
  和解码器一样，我们可以将多个 Mamba 块堆叠起来，带有标准规范化曾和残差连接交织组成，并将它们的输出作为下一个 Mamba 块的输入。它继承了状态空间模型序列长度的线性可伸缩性，同时实现了类似于 Transformer 的建模能力。
  
  它首先用一个线性投影，得到我们的输入嵌入，然后在应用选择性 SSM 之前进行卷积，以防止独立 token 计算。选择性 SSM 具有以下属性：
  * 通过离散化创建循环SSM
  * 在矩阵A上进行HiPPO初始化以捕获长程依赖关系
  * 选择性扫描算法选择性地压缩信息
  * 硬件感知算法加速计算
  
  在查看代码实现时，我们可以进一步扩展次架构，并探索端到端的示例
![](https://cloudflare.remsait.com/img/Mamba202511251530706.png)
  Mamba 即可以进行并行化训练，也可以按照线性缩放的复杂度进行推理，同时可以处理无限的上下文信息。 







## Reference
  [Mamba 基础讲解【SSM,LSSL,S4,S5,Mamba】](https://blog.csdn.net/zyw2002/article/details/136840829)
  
  [一文读懂：Mamba 模型，transformer的挑战者](https://zhuanlan.zhihu.com/p/26906183708)
  
  [文献](https://arxiv.org/abs/2312.00752)
  
  
  
  