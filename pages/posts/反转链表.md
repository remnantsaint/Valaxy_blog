---
categories: 
  - 算法基础
  - 链表
cover: 
date: 2023-04-02 20:47:07
image: 
layout: post
tags: 
  - 链表
time_warning: true
title: 反转链表
top: 
---
## 206. 反转链表
[题目链接](https://leetcode.cn/problems/reverse-linked-list/description/)  
题意：给出一个链表的头结点（首元结点），将该链表反转后，返回反转后的链表  
思路：  
如果再定义一个新的链表，实现链表的反转，这是对内存空间的浪费  
实际上只需要改变链表的 next 指针的指向，直接将链表反转，而不重新定义一个链表
### 方法一：双指针
直接在遍历链表的过程中原地修改，将当前结点的next指针改为指向前一个节点，然后将p和pre结点  都后移，需要借助p的后面结点，所以循环的开始先定义一个q=p->next;  
**事先定义一个指针等于一个节点，后面就可以让原来的指针等于这个新建的指针来回到原链表上**
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre,*p;
        pre=NULL;//pre一开始在头结点
        p=head;//p一开始在首元结点
        while(p!=NULL){
            ListNode *q=p->next;
            p->next=pre;//改变p点的指针指向
            pre=p;//将pre移向下一个结点
            p=q;//将p移向下一个结点
        }
        return pre;//遍历到结尾时，pre在最后一个结点
    }
};
```
### 方法二：递归
```c++
class Solution {
public:
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == NULL) return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        return reverse(cur,temp);
    }
    ListNode* reverseList(ListNode* head) {
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    }
};
```
### 方法三：头插法
```c++
public static ListNode reverseList1(ListNode head) {
    ListNode dumpyHead = new ListNode(-1); // 虚头节点
    dumpyHead.next = null;
    ListNode cur = head;
    while(cur != null){
        ListNode temp = cur.next;     // 记录下一个节点
        cur.next = dumpyHead.next;    // 当前节点接到新链表头
        dumpyHead.next = cur;         // 当前节点成为新链表头
        cur = temp;                   // 继续遍历原链表
    }
    return dumpyHead.next; // 返回新链表头
}

```