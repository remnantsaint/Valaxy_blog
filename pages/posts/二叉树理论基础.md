---
layout: post
title: 二叉树理论基础
date: 2025-08-24 15:10:24
updated: 2025-08-24
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---

二叉树的题目主要分为以下几部分：
* 二叉树的遍历方式
* 二叉树的属性
* 二叉树的修改与构造
* 求二叉搜索树的属性
* 二叉树公共祖先问题
* 二叉搜索树的修改与构造

## 二叉树的种类
### 满二叉树
  如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树  

  也就是说二叉树每一层都是满的  

  当深度为 k 时，第 k 层有 $2^{k - 1}$ 个结点，整颗有 $2^k - 1$ 个结点  

### 完全二叉树
  完全二叉树指出了最底层结点可能没填满，其余各层都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置  

  也就是说要么有两个孩子，要么没有孩子，要么只有左孩子  

  优先队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子结点的顺序关系  
### 二叉搜索树
  前面两个树的结点都是没有数值的，而二叉搜索树有数值，是一个**有序树**  
* 若左子树不空，则左子树上所有结点的值均小于它的根节点的值
* 若右子树不空，则右子树上所有节点的值均大于它的根节点的值
* 它的左、右子树也分别为二叉排序树
### 平衡二叉搜索树
  &emsp; 又被称为 AVL 树，具有以下性质：它是一个空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗二叉平衡树  

  &emsp; **C++ 中 map 、 set 、multimap 、multiset 的底层实现都是平衡二叉搜索树**，所以 map、set 的增删操作时间复杂度是 O(log n)。其他的 unordered_xxx 底层实现是哈希表，时间复杂度为 O(1)  

  &emsp; 为什么是 O(log n) ？  因为这些操作就是沿着树的一条路径向下，而因为是平衡二叉搜索树，所以左右的高度差不多，其时间复杂度也就是 O(log n)   

## 二叉树的存储方式
  二叉树既可以链式存储，也可以顺序存储。  

  链式存储就用指针，顺序存储就用数组。顾名思义，链式存储用指针把分布各个地址的结点串联到一起，顺序存储的内存是连续分布的。  

  链式存储即是每个节点都有左指针和右指针，指向左孩子和右孩子  

  顺序存储是从上到下，从左到右，在数组中依次存储，若父结点的下标是 i ，则它的左孩子就是`i * 2 + 1`，右孩子就是`i * 2 + 2`  
## 二叉树的遍历方式
  二叉树主要有两种遍历方式：深度优先遍历（先往深处走，遇到叶子结点再往回走）、广度优先遍历（一层一层的遍历）  

  - 深度优先遍历
  	- 前序遍历
  	- 中序遍历
  	- 后续遍历
  - 广度优先遍历
  	- 层次遍历

  前中后指的是中间结点的遍历顺序，即：

  - 前序遍历：中左右
  - 中序遍历：左中右
  - 后序遍历：左右中

  实现深度优先遍历用递归是最方便的，也就是借助栈用递归的方式实现  

  而广度优先遍历一般用队列来实现，这也是队列先进先出的特点决定，因为需要先进先出的结构才能一层层的遍历二叉树  

## 二叉树的定义
  二叉树定义结点代码如下：  
```c++
  struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    // 初始化
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 递归遍历
```c++
#include <bits/stdc++.h>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    char val;  // 节点存储值，可以改成 int 或其他类型
    TreeNode* left;
    TreeNode* right;
    TreeNode(char x) : val(x), left(nullptr), right(nullptr) {}
};

// 创建二叉树（先序输入，@ 表示空节点）
TreeNode* createTree() {
    char ch;
    cin >> ch;
    if (ch == '@') return nullptr;
    TreeNode* node = new TreeNode(ch);
    node->val = ch;
    node->left = createTree();
    node->right = createTree();
    return node;
}

// 前序遍历
void preorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}

// 中序遍历
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// 后序遍历（递归）
void postorder(TreeNode* root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}

// 层次遍历（BFS）
void levelOrder(TreeNode* root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* cur = q.front();
        q.pop();
        cout << cur->val << " ";
        if (cur->left) q.push(cur->left);
        if (cur->right) q.push(cur->right);
    }
}

// 主函数
int main() {
    TreeNode* root = createTree();

    preorder(root);
    cout << endl;

    inorder(root);
    cout << endl;

    postorder(root);
    cout << endl;

    levelOrder(root);
    cout << endl;

    system("pause");
    return 0;
}

/*
A B D @ @ E @ @ C F @ @ G @ @

构建的二叉树结构：
    A
   / \
  B   C
 / \ / \
D  E F  G

预期输出：
前序遍历: A B D E C F G
中序遍历: D B E A F C G
后序遍历: D E B F G C A
层次遍历: A B C D E F G
*/
```
### 144.二叉树前序遍历（递归）
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode* cur, vector<int> &vec){
        if(cur == nullptr){
            return;
        }
        vec.push_back(cur->val);
        preorder(cur->left,vec);
        preorder(cur->right,vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        preorder(root,result);
        return result;
    }
};
```
中序和后序同理，只是函数的加入数组在哪行  


## 迭代遍历代码
  递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址压入调用栈，等返回的时候从栈顶弹出上一次递归的各项参数  

  迭代就是用一个栈来模拟遍历，注意压入栈的顺序，要对应弹出的顺序  
### 前序遍历（迭代）
  前序遍历，每次先处理的是中间结点  

  那么先将中间结点放入栈中，然后将右孩子入栈，再加入左孩子  

  为什么先加入右孩子？  因为这样出栈的时候才是 中左右的顺序   
  
  代码如下：
```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```
前序遍历还算简单，但是没法直接改编成中序遍历，套路不一样  

### 中序遍历（迭代）
  在前序遍历的迭代法中，要访问的元素和要处理的元素顺序是一致的，都是中间结点
  
  但是中序不同，要从顶访问到最左边，再开始处理，造成了处理顺序和访问顺序不一致  
  
  那么再使用迭代法写中序遍历时，就要借用指针的遍历来帮助访问结点，栈则用来处理结点上的元素  
  
  代码如下：
```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
### 后序遍历
  先序遍历是中左右，入栈顺序是中右左，反转一下是左右中，就是后序遍历的顺序了  
  
  就是说前序遍历代码调整一下变为入栈中左右的顺序，最后反转一下  
  
  代码如下：
```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};

```

## 统一迭代法
  上文写的前中后序迭代法中，只有中序的逻辑不一样，那么，有没有统一的迭代方法？  
  
  上文迭代法中序遍历，无法同时解决访问节点和处理节点不一致的情况  
  
  那么就将访问的结点放入栈中，把要处理的结点也放入栈中，但是要做标记  
  
  下文是**空指针标记法**，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。   
  
  前序如下：  
```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```
中序如下： 
```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```
后序如下：  
```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```


  









参考：[代码随想录](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  