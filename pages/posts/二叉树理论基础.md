---
layout: post
title: 二叉树理论基础
date: 2025-08-24 15:10:24
updated: 2025-08-24
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
二叉树的题目主要分为以下几部分：
* 二叉树的遍历方式
* 二叉树的属性
* 二叉树的修改与构造
* 求二叉搜索树的属性
* 二叉树公共祖先问题
* 二叉搜索树的修改与构造

## 二叉树的种类
### 满二叉树
  如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树  

  也就是说二叉树每一层都是满的  

  当深度为 k 时，第 k 层有 $2^{k - 1}$ 个结点，整颗有 $2^k - 1$ 个结点  

### 完全二叉树
  完全二叉树指出了最底层结点可能没填满，其余各层都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置  

  也就是说要么有两个孩子，要么没有孩子，要么只有左孩子  

  优先队列其实就是一个堆，堆就是一颗完全二叉树，同时保证父子结点的顺序关系  
### 二叉搜索树
  前面两个树的结点都是没有数值的，而二叉搜索树有数值，是一个**有序树**  
* 若左子树不空，则左子树上所有结点的值均小于它的根节点的值
* 若右子树不空，则右子树上所有节点的值均大于它的根节点的值
* 它的左、右子树也分别为二叉排序树
### 平衡二叉搜索树
  &emsp; 又被称为 AVL 树，具有以下性质：它是一个空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗二叉平衡树  

  &emsp; **C++ 中 map 、 set 、multimap 、multiset 的底层实现都是平衡二叉搜索树**，所以 map、set 的增删操作时间复杂度是 O(log n)。其他的 unordered_xxx 底层实现是哈希表，时间复杂度为 O(1)  

  &emsp; 为什么是 O(log n) ？  因为这些操作就是沿着树的一条路径向下，而因为是平衡二叉搜索树，所以左右的高度差不多，其时间复杂度也就是 O(log n)   

## 二叉树的存储方式
  二叉树既可以链式存储，也可以顺序存储。  

  链式存储就用指针，顺序存储就用数组。顾名思义，链式存储用指针把分布各个地址的结点串联到一起，顺序存储的内存是连续分布的。  

  链式存储即是每个节点都有左指针和右指针，指向左孩子和右孩子  

  顺序存储是从上到下，从左到右，在数组中依次存储，若父结点的下标是 i ，则它的左孩子就是`i * 2 + 1`，右孩子就是`i * 2 + 2`  
## 二叉树的遍历方式
  二叉树主要有两种遍历方式：深度优先遍历（先往深处走，遇到叶子结点再往回走）、广度优先遍历（一层一层的遍历）  

  - 深度优先遍历
  	- 前序遍历
  	- 中序遍历
  	- 后续遍历
  - 广度优先遍历
  	- 层次遍历

  前中后指的是中间结点的遍历顺序，即：
  
  - 前序遍历：中左右
  - 中序遍历：左中右
  - 后序遍历：左右中

  实现深度优先遍历用递归是最方便的，也就是借助栈用递归的方式实现  
  
  而广度优先遍历一般用队列来实现，这也是队列先进先出的特点决定，因为需要先进先出的结构才能一层层的遍历二叉树  
  
## 二叉树的定义
  二叉树定义结点代码如下：  
```c++
  struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    // 初始化
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 创建以及遍历代码
```c++
#include <bits/stdc++.h>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    char val;  // 节点存储值，可以改成 int 或其他类型
    TreeNode* left;
    TreeNode* right;
    TreeNode(char x) : val(x), left(nullptr), right(nullptr) {}
};

// 创建二叉树（先序输入，@ 表示空节点）
TreeNode* createTree() {
    char ch;
    cin >> ch;
    if (ch == '@') return nullptr;
    TreeNode* node = new TreeNode(ch);
    node->val = ch;
    node->left = createTree();
    node->right = createTree();
    return node;
}

// 前序遍历
void preorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}

// 中序遍历
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

// 后序遍历（递归）
void postorder(TreeNode* root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}

// 层次遍历（BFS）
void levelOrder(TreeNode* root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* cur = q.front();
        q.pop();
        cout << cur->val << " ";
        if (cur->left) q.push(cur->left);
        if (cur->right) q.push(cur->right);
    }
}

// 主函数
int main() {
    TreeNode* root = createTree();

    preorder(root);
    cout << endl;

    inorder(root);
    cout << endl;

    postorder(root);
    cout << endl;

    levelOrder(root);
    cout << endl;

    system("pause");
    return 0;
}

/*
A B D @ @ E @ @ C F @ @ G @ @

构建的二叉树结构：
    A
   / \
  B   C
 / \ / \
D  E F  G

预期输出：
前序遍历: A B D E C F G
中序遍历: D B E A F C G
后序遍历: D E B F G C A
层次遍历: A B C D E F G
*/
```
















参考：[代码随想录](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  