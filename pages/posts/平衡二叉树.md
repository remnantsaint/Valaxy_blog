---
layout: post
title: 平衡二叉树
date: 2025-09-04 09:59:53
updated: 2025-09-04
time_warning: true 
cover: 
top: 
tags: 
 - 二叉树
 - AVL
categories: 
 - 算法基础
 - 二叉树
# author: @Remsait
---
## 110. 平衡二叉树
[题目链接](https://leetcode.cn/problems/balanced-binary-tree/)  
题意：给一个二叉树，判断是否为平衡二叉树  

### 平衡二叉树定义
  **一个二叉树每个节点的左右两个子树高度差的绝对值不超过1**  
  
### 后序递归
  一个节点的高度是该节点到最下面的距离，平衡二叉树需要比较高度，必然是要后序遍历（高度计算具有自底向上的依赖关系
   
  1. 明确递归函数的参数和返回值  
  参数：当前传入节点  
  返回值：以当前传入节点为根节点的树的高度  
  如果已经不是平衡二叉树了，可以返回 -1 来标记已经不符合平衡树的规则  
  代码：`int getHeight(TreeNode* node)`  
  
  2. 明确终止条件  
  递归的过程中依然是遇到空节点了为终止，返回 0，表示当前节点为根节点的树高度为 0  
  代码：`if(node == NULL) return 0;`  
  
  3. 明确单层递归的逻辑  
  如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树？当然是计算其左子树高度和右子树高度的差值  
  分别求出左右子树的高度，然后如果差值小于等于 1，则返回当前二叉树的高度，否则返回 -1，表示已经不是二叉平衡树了  
  代码如下：  
```c++
int leftHeight = getHeight(node->left); // 左
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node->right); // 右
if (rightHeight == -1) return -1;
return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight); 
// 以当前节点为根节点的树的最大高度
```
  此时递归的函数就写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，就返回 -1.  
  
  整体代码如下：  
```c++
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left); // 左
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right); // 右
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight); // 中
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

### 迭代
  在 104. 二叉树的最大深度 题目中，可以用层序遍历来求深度，但是不能直接用层序遍历求高度了  
  本题的迭代方式可以先定义一个函数，专门用来求高度  
  这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度  
  代码如下：
```c++
class Solution {
private:
    int getDepth(TreeNode* cur) {
        stack<TreeNode*> st;
        if (cur != NULL) st.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);
                depth++;
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }

public:
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return true;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            if (abs(getDepth(node->left) - getDepth(node->right)) > 1) {
                return false;
            }
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return true;
    }
};
```
本体用迭代法效率很低，因为没有很好的模拟回溯的过程，所以迭代法有多重复的计算  


















参考：[代码随想录](https://www.programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)