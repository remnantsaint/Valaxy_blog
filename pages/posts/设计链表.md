---
layout: post
title: 设计链表
date: 2025-08-06 11:39:18
cover: 
top: 
tags: 
 - 链表
categories: 
 - 算法基础
 - 链表
# author: @Remsait
---
## 707. 设计链表
[题目链接](https://leetcode.cn/problems/design-linked-list/description/)  
题意：在链表中实现以下功能  
* get(index)：获取链表中第 index 个节点的值，如果索引无效返回 -1
* addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点，插入后新节点成为链表的第一个节点
* addAtTail(val)：在链表的最后添加一个节点
* addAtIndex(index, val)：在链表的第 index 个节点之前添加值为 val 的节点
* deleteAtIndex(index)：如果索引 index 有效，则删除链表中第 index 个节点

方法采用设置一个虚拟头节点，代码如下：  
```c++
/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
class MyLinkedList {
   public:
    // 定义链表节点结构体
    struct ListNode {
        int data;
        ListNode* next;
        ListNode(int val) : data(val), next(nullptr) {}
    };

    ListNode* head;  // 虚拟头结点
    int size;        // 链表大小

    MyLinkedList() {
        // 创建虚拟头结点，类似 H = (List)malloc(sizeof(List))
        head = new ListNode(0);  // 虚拟头结点，数据域无意义
        head->next = nullptr;
        size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1
    // 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        // 检查索引合法性
        if (index < 0 || index >= size) {
            return -1;
        }
        // 从首元结点开始遍历
        ListNode* p = head->next;
        while (index--) {
            p = p->next;
        }
        return p->data;
    }

    void addAtHead(int val) {
        // 头插法
        ListNode* newNode = new ListNode(val);
        newNode->next = head->next;
        head->next = newNode;
        size++;
    }

    void addAtTail(int val) {
        // 尾插法
        ListNode* newNode = new ListNode(val);
        ListNode* r = head;  // r是尾指针，找到最后一个结点
        // 遍历到最后一个结点
        while (r->next != nullptr) {
            r = r->next;
        }
        // 插入新节点
        r->next = newNode;
        newNode->next = nullptr;
        size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则在头部插入节点
    void addAtIndex(int index, int val) {
        // 检查索引合法性
        if (index > size) {
            return;
        }
        // 如果在头部插入
        if (index <= 0) {
            addAtHead(val);
            return;
        }
        // 如果在尾部插入
        if (index == size) {
            addAtTail(val);
            return;
        }
        // 在中间插入
        ListNode* pre = head;  // 前驱结点
        // 找到插入位置的前一个节点
        while (index--) {
            pre = pre->next;
        }
        ListNode* newNode = new ListNode(val);
        newNode->next = pre->next;
        pre->next = newNode;
        size++;
    }

    void deleteAtIndex(int index) {
        // 检查索引合法性
        if (index < 0 || index >= size) {
            return;
        }

        // 找到要删除节点的前驱
        ListNode* pre = head;  // 前驱结点
        // 移动到要删除节点的前一个位置
        while (index--) {
            pre = pre->next;
        }
        // 删除节点
        ListNode* toDelete = pre->next;
        pre->next = toDelete->next;
        delete toDelete;
        // delete命令指示释放了tmp指针原本所指的那部分内存，
        // 被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        // 如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        // 如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        toDelete = nullptr;
        size--;
    }
    // 打印链表
    void printLinkedList() {
        ListNode* cur = head;
        while (cur->next != nullptr) {
            cout << cur->next->data << " ";
            cur = cur->next;
        }
        cout << endl;
    }
    // 析构函数，释放所有节点内存
    ~MyLinkedList() {
        ListNode* current = head;
        while (current != nullptr) {
            ListNode* next = current->next;
            delete current;
            current = next;
        }
    }
};

```







参考：[代码随想录](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)