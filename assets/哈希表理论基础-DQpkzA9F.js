import{_ as h}from"./ValaxyMain.vue_vue_type_style_index_0_lang-Lj6vZGyG.js";import{u as c,c as p,o as b,w as n,r as a,g as l,h as t,f,p as s}from"./app-D6Hejker.js";import"./YunFooter-BsWuc4uy.js";import"./YunCard.vue_vue_type_script_setup_true_lang-DrznGDEn.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-Dma2ZTu7.js";import"./post-C0fFnzag.js";const A={__name:"哈希表理论基础",setup(k,{expose:i}){const r=JSON.parse('{"title":"哈希表理论基础","description":"","frontmatter":{"layout":"post","title":"哈希表理论基础","date":"2025-08-09 09:08:16","cover":null,"top":null,"tags":["哈希表","stl"],"categories":["算法基础","哈希表"]},"headers":[{"level":2,"title":"理论基础","slug":"理论基础","link":"#理论基础","children":[{"level":3,"title":"哈希表","slug":"哈希表","link":"#哈希表","children":[]},{"level":3,"title":"哈希函数","slug":"哈希函数","link":"#哈希函数","children":[]},{"level":3,"title":"哈希碰撞","slug":"哈希碰撞","link":"#哈希碰撞","children":[]},{"level":3,"title":"常见的三种哈希结构","slug":"常见的三种哈希结构","link":"#常见的三种哈希结构","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"relativePath":"pages/posts/哈希表理论基础.md","path":"/home/runner/work/remnantsaint.github.io/remnantsaint.github.io/pages/posts/哈希表理论基础.md","lastUpdated":1758348498000}'),d=c(),u=r.frontmatter||{};return d.meta.frontmatter=Object.assign(d.meta.frontmatter||{},r.frontmatter||{}),s("pageData",r),s("valaxy:frontmatter",u),globalThis.$frontmatter=u,i({frontmatter:{layout:"post",title:"哈希表理论基础",date:"2025-08-09 09:08:16",cover:null,top:null,tags:["哈希表","stl"],categories:["算法基础","哈希表"]}}),(e,o)=>{const m=h;return b(),p(m,{frontmatter:f(u)},{"main-content-md":n(()=>[...o[0]||(o[0]=[l("h2",{id:"理论基础",tabindex:"-1"},[t("理论基础 "),l("a",{class:"header-anchor",href:"#理论基础","aria-label":'Permalink to "理论基础"'},"​")],-1),l("h3",{id:"哈希表",tabindex:"-1"},[t("哈希表 "),l("a",{class:"header-anchor",href:"#哈希表","aria-label":'Permalink to "哈希表"'},"​")],-1),l("p",null,[t("什么是哈希表？"),l("br"),t(" 哈希表是根据关键码的值而直接进行访问的数据结构"),l("br"),t(" 简单来说数组就是哈希表，用处是"),l("strong",null,"用来快速判断一个元素是否出现在集合里"),l("br"),t(" 例如要查找一个数是否在数组里，枚举的时间复杂度是 O(1)，而哈希表只需要 O(1)"),l("br"),t(" 将数映射到哈希表上就涉及到了 "),l("strong",null,"哈希函数")],-1),l("h3",{id:"哈希函数",tabindex:"-1"},[t("哈希函数 "),l("a",{class:"header-anchor",href:"#哈希函数","aria-label":'Permalink to "哈希函数"'},"​")],-1),l("p",null,[t("哈希函数，把数直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这个数是否在数组内了。"),l("br"),t(" 如果存的不是整型数而是其他类型，可以用 hashCode 函数来通过特征编码方式转化为数值，再通过"),l("code",null,"index = hashCode(name) % tableSize"),t("来映射"),l("br"),t(" 如果索引大于哈希表的长度，就应该对其取模，保证在长度内。"),l("br"),t(" 那么如果两个数被映射到同一下标上怎么办？ 下面就用到了哈希碰撞")],-1),l("h3",{id:"哈希碰撞",tabindex:"-1"},[t("哈希碰撞 "),l("a",{class:"header-anchor",href:"#哈希碰撞","aria-label":'Permalink to "哈希碰撞"'},"​")],-1),l("p",null,[t("两个数被映射到同一索引下标的位置，这一现象被称作哈希碰撞"),l("br"),t(" 有两种解决办法：拉链法和线性探测法")],-1),l("h4",{id:"拉链法",tabindex:"-1"},[t("拉链法 "),l("a",{class:"header-anchor",href:"#拉链法","aria-label":'Permalink to "拉链法"'},"​")],-1),l("p",null,[t("就是在索引处建一个链表，每重复一个数就在后面插入"),l("br"),t(" 应该适当选择哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间")],-1),l("h4",{id:"线性探测法",tabindex:"-1"},[t("线性探测法 "),l("a",{class:"header-anchor",href:"#线性探测法","aria-label":'Permalink to "线性探测法"'},"​")],-1),l("p",null,[t("使用线性探测法时，首先要保证 tableSize 大于 dataSize，即数据规模小于哈希表大小，利用哈希表中的空位解决问题"),l("br"),t(" 例如发成哈希碰撞，就把后来者往后移动，直到找到空位就存在那")],-1),l("h3",{id:"常见的三种哈希结构",tabindex:"-1"},[t("常见的三种哈希结构 "),l("a",{class:"header-anchor",href:"#常见的三种哈希结构","aria-label":'Permalink to "常见的三种哈希结构"'},"​")],-1),l("p",null,"当我们想用哈希法来解决问题时，一般会选用如下三种数据结构",-1),l("ul",null,[l("li",null,"数组"),l("li",null,"set（集合）"),l("li",null,"map（映射）")],-1),l("h4",{id:"set-集合",tabindex:"-1"},[t("set（集合） "),l("a",{class:"header-anchor",href:"#set-集合","aria-label":'Permalink to "set（集合）"'},"​")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"集合"),l("th",null,"底层实现"),l("th",null,"是否有序"),l("th",null,"数值是否可以重复"),l("th",null,"能否更改数值"),l("th",null,"查询效率"),l("th",null,"增删效率")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"std::set")]),l("td",null,"红黑树"),l("td",null,"有序"),l("td",null,"否"),l("td",null,"否"),l("td",null,"O(log n)"),l("td",null,"O(log n)")]),l("tr",null,[l("td",null,[l("code",null,"std::multiset")]),l("td",null,"红黑树"),l("td",null,"有序"),l("td",null,"是"),l("td",null,"否"),l("td",null,"O(log n)"),l("td",null,"O(log n)")]),l("tr",null,[l("td",null,[l("code",null,"std::unordered_set")]),l("td",null,"哈希表"),l("td",null,"无序"),l("td",null,"否"),l("td",null,"否"),l("td",null,"O(1)"),l("td",null,"O(1)")])])],-1),l("p",null,"std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以 key 值是有序的，但 key 不可以修改，改动 key 值会导致整棵树的错乱，所以只能删除和增加。",-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"方法"),l("th",null,"作用")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"s.insert(x)")]),l("td",null,[t("插入元素 "),l("code",null,"x"),t("（自动去重，重复插入无效）")])]),l("tr",null,[l("td",null,[l("code",null,"s.erase(x)")]),l("td",null,[t("删除元素 "),l("code",null,"x"),t("（按值删除）")])]),l("tr",null,[l("td",null,[l("code",null,"s.find(x)")]),l("td",null,[t("查找元素 "),l("code",null,"x"),t("，返回迭代器（找到返回元素位置，没找到返回 "),l("code",null,"s.end()"),t("）")])]),l("tr",null,[l("td",null,[l("code",null,"s.count(x)")]),l("td",null,[t("返回元素 "),l("code",null,"x"),t(" 出现的次数（"),l("code",null,"unordered_set"),t(" 中是 0 或 1）")])]),l("tr",null,[l("td",null,[l("code",null,"s.size()")]),l("td",null,"返回集合中元素个数")]),l("tr",null,[l("td",null,[l("code",null,"s.empty()")]),l("td",null,[t("判断集合是否为空，空返回 "),l("code",null,"true")])]),l("tr",null,[l("td",null,[l("code",null,"s.clear()")]),l("td",null,"清空集合")]),l("tr",null,[l("td",null,[l("code",null,"s.begin()"),t(" / "),l("code",null,"s.end()")]),l("td",null,"返回迭代器范围（用于遍历）")])])],-1),l("h4",{id:"map-映射",tabindex:"-1"},[t("map（映射） "),l("a",{class:"header-anchor",href:"#map-映射","aria-label":'Permalink to "map（映射）"'},"​")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"映射"),l("th",null,"底层实现"),l("th",null,"是否有序"),l("th",null,"数值是否可以重复"),l("th",null,"能否更改数值"),l("th",null,"查询效率"),l("th",null,"增删效率")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("code",null,"std::map")]),l("td",null,"红黑树"),l("td",null,"key有序"),l("td",null,"key不可重复"),l("td",null,"key不可修改"),l("td",null,"O(log n)"),l("td",null,"O(log n)")]),l("tr",null,[l("td",null,[l("code",null,"std::multimap")]),l("td",null,"红黑树"),l("td",null,"key有序"),l("td",null,"key可重复"),l("td",null,"key不可修改"),l("td",null,"O(log n)"),l("td",null,"O(log n)")]),l("tr",null,[l("td",null,[l("code",null,"std::unordered_map")]),l("td",null,"哈希表"),l("td",null,"key无序"),l("td",null,"key不可重复"),l("td",null,"key不可修改"),l("td",null,"O(1)"),l("td",null,"O(1)")])])],-1),l("p",null,"std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。",-1),l("h4",{id:"用法",tabindex:"-1"},[t("用法 "),l("a",{class:"header-anchor",href:"#用法","aria-label":'Permalink to "用法"'},"​")],-1),l("p",null,[t("当我们要用集合来解决哈希问题时，优先使用 unordered_set，因为它的查询和增删效率都是最优的，如果需要集合有序，那就用 set ，如果要求不仅有序还要有重复数据的话，就用 multiset"),l("br"),t(" 再来看 map ，map 时一个 <key , value> 的数据结构，在 map 中对 key 有限制，对 value 是没有限制的，因为 key 的存储方式使用红黑树实现")],-1),l("h3",{id:"总结",tabindex:"-1"},[t("总结 "),l("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),l("p",null,[l("strong",null,"当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法"),l("br"),t(" 哈希法是"),l("strong",null,"牺牲空间换取时间")],-1),l("p",null,[t("参考："),l("a",{href:"https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8",target:"_blank",rel:"noreferrer"},"代码随想录")],-1)])]),"main-header":n(()=>[a(e.$slots,"main-header")]),"main-header-after":n(()=>[a(e.$slots,"main-header-after")]),"main-nav":n(()=>[a(e.$slots,"main-nav")]),"main-content":n(()=>[a(e.$slots,"main-content")]),"main-content-after":n(()=>[a(e.$slots,"main-content-after")]),"main-nav-before":n(()=>[a(e.$slots,"main-nav-before")]),"main-nav-after":n(()=>[a(e.$slots,"main-nav-after")]),comment:n(()=>[a(e.$slots,"comment")]),footer:n(()=>[a(e.$slots,"footer")]),aside:n(()=>[a(e.$slots,"aside")]),"aside-custom":n(()=>[a(e.$slots,"aside-custom")]),default:n(()=>[a(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{A as default};
