import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang-Lj6vZGyG.js";import{u as m,c as q,o as f,w as n,r as u,g as l,h as d,f as O,p as s}from"./app-D6Hejker.js";import"./YunFooter-BsWuc4uy.js";import"./YunCard.vue_vue_type_script_setup_true_lang-DrznGDEn.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-Dma2ZTu7.js";import"./post-C0fFnzag.js";const w={__name:"栈与队列理论基础",setup(b,{expose:c}){const e=JSON.parse('{"title":"栈与队列理论基础","description":"","frontmatter":{"layout":"post","title":"栈与队列理论基础","date":"2025-08-19 10:03:16","updated":"2025-08-19","time_warning":true,"cover":null,"top":null,"tags":["stl"],"categories":["算法基础","栈与队列"]},"headers":[],"relativePath":"pages/posts/栈与队列理论基础.md","path":"/home/runner/work/remnantsaint.github.io/remnantsaint.github.io/pages/posts/栈与队列理论基础.md","lastUpdated":1758348498000}'),r=m(),o=e.frontmatter||{};return r.meta.frontmatter=Object.assign(r.meta.frontmatter||{},e.frontmatter||{}),s("pageData",e),s("valaxy:frontmatter",o),globalThis.$frontmatter=o,c({frontmatter:{layout:"post",title:"栈与队列理论基础",date:"2025-08-19 10:03:16",updated:"2025-08-19",time_warning:!0,cover:null,top:null,tags:["stl"],categories:["算法基础","栈与队列"]}}),(t,a)=>{const i=p;return f(),q(i,{frontmatter:O(o)},{"main-content-md":n(()=>[...a[0]||(a[0]=[l("p",null,[d("栈是先进后出，队列是先进先出"),l("br"),d(" 栈和队列是 STL（C++标准库）里的两个数据结构"),l("br"),d(" C++标准库是有多个版本的，我们使用的是 SGI STL，由Silicon Graphics Computer Systems公司参照 HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，可读性很高"),l("br"),l("br"),d(" 栈提供 push 和 pop 等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器（iterator)，不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素"),l("br"),d(" 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。"),l("br"),d(" 所以 STL 中栈往往不被归类为容器，而被归类为 container adapter(容器适配器)"),l("br"),d(" STL 中的栈底层实现可以是 vector, deque, list，主要就是数组和链表的底层实现，默认以 deque 双向链表封住一端实现")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"方法/操作"),l("th",null,"语法"),l("th",null,"功能描述"),l("th",null,"返回值"),l("th",null,"时间复杂度"),l("th",null,"示例代码")])]),l("tbody",null,[l("tr",null,[l("td",null,"包含头文件"),l("td",null,[l("code",null,"#include <stack>")]),l("td",null,"包含栈的头文件"),l("td",null,"-"),l("td",null,"-"),l("td",null,[l("code",null,"#include <stack>")])]),l("tr",null,[l("td",null,"声明栈"),l("td",null,[l("code",null,"stack<type> name;")]),l("td",null,"创建空栈"),l("td",null,"-"),l("td",null,"O(1)"),l("td",null,[l("code",null,"stack<int> s;")])]),l("tr",null,[l("td",null,"拷贝构造"),l("td",null,[l("code",null,"stack<type> s2(s1);")]),l("td",null,"用s1初始化s2"),l("td",null,"-"),l("td",null,"O(n)"),l("td",null,[l("code",null,"stack<int> s2(s1);")])]),l("tr",null,[l("td",null,"入栈"),l("td",null,[l("code",null,"push(value)")]),l("td",null,"将元素压入栈顶"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"s.push(10);")])]),l("tr",null,[l("td",null,"出栈"),l("td",null,[l("code",null,"pop()")]),l("td",null,"删除栈顶元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"s.pop();")])]),l("tr",null,[l("td",null,"访问栈顶"),l("td",null,[l("code",null,"top()")]),l("td",null,"获取栈顶元素"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = s.top();")])]),l("tr",null,[l("td",null,"判断空栈"),l("td",null,[l("code",null,"empty()")]),l("td",null,"检查栈是否为空"),l("td",null,"bool"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(s.empty())")])]),l("tr",null,[l("td",null,"获取大小"),l("td",null,[l("code",null,"size()")]),l("td",null,"返回栈中元素个数"),l("td",null,"size_t"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int n = s.size();")])]),l("tr",null,[l("td",null,"交换"),l("td",null,[l("code",null,"swap(s2)")]),l("td",null,"交换两个栈的内容"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"s1.swap(s2);")])]),l("tr",null,[l("td",null,"赋值运算符"),l("td",null,[l("code",null,"s1 = s2")]),l("td",null,"将s2赋值给s1"),l("td",null,"stack&"),l("td",null,"O(n)"),l("td",null,[l("code",null,"s1 = s2;")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"s1 == s2")]),l("td",null,"比较两栈是否相等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(s1 == s2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"s1 != s2")]),l("td",null,"比较两栈是否不等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(s1 != s2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"s1 < s2")]),l("td",null,"字典序比较"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(s1 < s2)")])]),l("tr",null,[l("td",null,"安全访问"),l("td",null,[l("code",null,"!s.empty() && s.top()")]),l("td",null,"安全获取栈顶"),l("td",null,"元素值"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(!s.empty()) x = s.top();")])]),l("tr",null,[l("td",null,"安全出栈"),l("td",null,[l("code",null,"!s.empty() && s.pop()")]),l("td",null,"安全删除栈顶"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(!s.empty()) s.pop();")])]),l("tr",null,[l("td",null,[l("br")]),l("td"),l("td"),l("td"),l("td"),l("td")])])],-1),l("p",null,[d("SGI STL中队列一样是以deque为缺省情况下的底部结构。"),l("br"),d(" 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"方法/操作"),l("th",null,"语法"),l("th",null,"功能描述"),l("th",null,"返回值"),l("th",null,"时间复杂度"),l("th",null,"示例代码")])]),l("tbody",null,[l("tr",null,[l("td",null,"包含头文件"),l("td",null,[l("code",null,"#include <queue>")]),l("td",null,"包含队列的头文件"),l("td",null,"-"),l("td",null,"-"),l("td",null,[l("code",null,"#include <queue>")])]),l("tr",null,[l("td",null,"声明队列"),l("td",null,[l("code",null,"queue<type> name;")]),l("td",null,"创建空队列"),l("td",null,"-"),l("td",null,"O(1)"),l("td",null,[l("code",null,"queue<int> q;")])]),l("tr",null,[l("td",null,"拷贝构造"),l("td",null,[l("code",null,"queue<type> q2(q1);")]),l("td",null,"用q1初始化q2"),l("td",null,"-"),l("td",null,"O(n)"),l("td",null,[l("code",null,"queue<int> q2(q1);")])]),l("tr",null,[l("td",null,"入队(尾部)"),l("td",null,[l("code",null,"push(value)")]),l("td",null,"将元素加入队尾"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"q.push(10);")])]),l("tr",null,[l("td",null,"出队(头部)"),l("td",null,[l("code",null,"pop()")]),l("td",null,"删除队头元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"q.pop();")])]),l("tr",null,[l("td",null,"访问队头"),l("td",null,[l("code",null,"front()")]),l("td",null,"获取队头元素"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = q.front();")])]),l("tr",null,[l("td",null,"访问队尾"),l("td",null,[l("code",null,"back()")]),l("td",null,"获取队尾元素"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int y = q.back();")])]),l("tr",null,[l("td",null,"判断空队列"),l("td",null,[l("code",null,"empty()")]),l("td",null,"检查队列是否为空"),l("td",null,"bool"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(q.empty())")])]),l("tr",null,[l("td",null,"获取大小"),l("td",null,[l("code",null,"size()")]),l("td",null,"返回队列中元素个数"),l("td",null,"size_t"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int n = q.size();")])]),l("tr",null,[l("td",null,"交换"),l("td",null,[l("code",null,"swap(q2)")]),l("td",null,"交换两个队列的内容"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"q1.swap(q2);")])]),l("tr",null,[l("td",null,"赋值运算符"),l("td",null,[l("code",null,"q1 = q2")]),l("td",null,"将q2赋值给q1"),l("td",null,"queue&"),l("td",null,"O(n)"),l("td",null,[l("code",null,"q1 = q2;")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"q1 == q2")]),l("td",null,"比较两队列是否相等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(q1 == q2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"q1 != q2")]),l("td",null,"比较两队列是否不等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(q1 != q2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"q1 < q2")]),l("td",null,"字典序比较"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(q1 < q2)")])]),l("tr",null,[l("td",null,"安全访问队头"),l("td",null,[l("code",null,"!q.empty() && q.front()")]),l("td",null,"安全获取队头"),l("td",null,"元素值"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(!q.empty()) x = q.front();")])]),l("tr",null,[l("td",null,"安全访问队尾"),l("td",null,[l("code",null,"!q.empty() && q.back()")]),l("td",null,"安全获取队尾"),l("td",null,"元素值"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(!q.empty()) y = q.back();")])]),l("tr",null,[l("td",null,"安全出队"),l("td",null,[l("code",null,"!q.empty() && q.pop()")]),l("td",null,"安全删除队头"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(!q.empty()) q.pop();")])])])],-1),l("br",null,null,-1),l("p",null,"双端队列操作如下：",-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,"方法/操作"),l("th",null,"语法"),l("th",null,"功能描述"),l("th",null,"返回值"),l("th",null,"时间复杂度"),l("th",null,"示例代码")])]),l("tbody",null,[l("tr",null,[l("td",null,"包含头文件"),l("td",null,[l("code",null,"#include <deque>")]),l("td",null,"包含双端队列头文件"),l("td",null,"-"),l("td",null,"-"),l("td",null,[l("code",null,"#include <deque>")])]),l("tr",null,[l("td",null,"声明双端队列"),l("td",null,[l("code",null,"deque<type> d;")]),l("td",null,"创建空双端队列"),l("td",null,"-"),l("td",null,"O(1)"),l("td",null,[l("code",null,"deque<int> d;")])]),l("tr",null,[l("td",null,"拷贝构造"),l("td",null,[l("code",null,"deque<type> d2(d1);")]),l("td",null,"用 d1 初始化 d2"),l("td",null,"-"),l("td",null,"O(n)"),l("td",null,[l("code",null,"deque<int> d2(d1);")])]),l("tr",null,[l("td",null,"初始化"),l("td",null,[l("code",null,"deque<type> d(n, val);")]),l("td",null,"创建含 n 个值为 val 的元素"),l("td",null,"-"),l("td",null,"O(n)"),l("td",null,[l("code",null,"deque<int> d(5, 10);")])]),l("tr",null,[l("td",null,"随机访问"),l("td",null,[l("code",null,"d[i]")]),l("td",null,"获取下标为 i 的元素"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = d[2];")])]),l("tr",null,[l("td",null,"安全访问"),l("td",null,[l("code",null,"d.at(i)")]),l("td",null,"获取下标 i 的元素并检查越界"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = d.at(2);")])]),l("tr",null,[l("td",null,"获取首元素"),l("td",null,[l("code",null,"d.front()")]),l("td",null,"返回首元素引用"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = d.front();")])]),l("tr",null,[l("td",null,"获取尾元素"),l("td",null,[l("code",null,"d.back()")]),l("td",null,"返回尾元素引用"),l("td",null,"元素引用"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int x = d.back();")])]),l("tr",null,[l("td",null,"插入尾部"),l("td",null,[l("code",null,"d.push_back(val)")]),l("td",null,"在队尾插入元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"d.push_back(10);")])]),l("tr",null,[l("td",null,"插入头部"),l("td",null,[l("code",null,"d.push_front(val)")]),l("td",null,"在队首插入元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"d.push_front(20);")])]),l("tr",null,[l("td",null,"删除尾部"),l("td",null,[l("code",null,"d.pop_back()")]),l("td",null,"删除队尾元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"d.pop_back();")])]),l("tr",null,[l("td",null,"删除头部"),l("td",null,[l("code",null,"d.pop_front()")]),l("td",null,"删除队首元素"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"d.pop_front();")])]),l("tr",null,[l("td",null,"任意位置插入"),l("td",null,[l("code",null,"d.insert(pos, val)")]),l("td",null,"在 pos 位置插入 val"),l("td",null,"迭代器"),l("td",null,"O(n)"),l("td",null,[l("code",null,"d.insert(d.begin()+1, 30);")])]),l("tr",null,[l("td",null,"任意位置删除"),l("td",null,[l("code",null,"d.erase(pos)")]),l("td",null,"删除 pos 位置的元素"),l("td",null,"迭代器"),l("td",null,"O(n)"),l("td",null,[l("code",null,"d.erase(d.begin());")])]),l("tr",null,[l("td",null,"清空"),l("td",null,[l("code",null,"d.clear()")]),l("td",null,"清空所有元素"),l("td",null,"void"),l("td",null,"O(n)"),l("td",null,[l("code",null,"d.clear();")])]),l("tr",null,[l("td",null,"判断空"),l("td",null,[l("code",null,"d.empty()")]),l("td",null,"检查是否为空"),l("td",null,"bool"),l("td",null,"O(1)"),l("td",null,[l("code",null,"if(d.empty())")])]),l("tr",null,[l("td",null,"获取大小"),l("td",null,[l("code",null,"d.size()")]),l("td",null,"返回元素个数"),l("td",null,"size_t"),l("td",null,"O(1)"),l("td",null,[l("code",null,"int n = d.size();")])]),l("tr",null,[l("td",null,"改变大小"),l("td",null,[l("code",null,"d.resize(n)")]),l("td",null,"调整大小，多余删掉，不足补默认值"),l("td",null,"void"),l("td",null,"O(n)"),l("td",null,[l("code",null,"d.resize(10);")])]),l("tr",null,[l("td",null,"交换"),l("td",null,[l("code",null,"d1.swap(d2)")]),l("td",null,"交换两个 deque 内容"),l("td",null,"void"),l("td",null,"O(1)"),l("td",null,[l("code",null,"d1.swap(d2);")])]),l("tr",null,[l("td",null,"赋值运算符"),l("td",null,[l("code",null,"d1 = d2")]),l("td",null,"将 d2 赋值给 d1"),l("td",null,"deque&"),l("td",null,"O(n)"),l("td",null,[l("code",null,"d1 = d2;")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"d1 == d2")]),l("td",null,"比较两个 deque 是否相等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(d1 == d2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"d1 != d2")]),l("td",null,"比较两个 deque 是否不等"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(d1 != d2)")])]),l("tr",null,[l("td",null,"比较运算符"),l("td",null,[l("code",null,"d1 < d2")]),l("td",null,"字典序比较"),l("td",null,"bool"),l("td",null,"O(n)"),l("td",null,[l("code",null,"if(d1 < d2)")])]),l("tr",null,[l("td",null,"遍历（迭代器）"),l("td",null,[l("code",null,"for(auto it=d.begin(); it!=d.end(); ++it)")]),l("td",null,"遍历所有元素"),l("td",null,"迭代器"),l("td",null,"O(n)"),l("td",null,[l("code",null,"for(int x : d){...}")])]),l("tr",null,[l("td",null,"反向遍历"),l("td",null,[l("code",null,"rbegin(), rend()")]),l("td",null,"从尾到头遍历"),l("td",null,"迭代器"),l("td",null,"O(n)"),l("td",null,[l("code",null,"for(auto it=d.rbegin(); it!=d.rend(); ++it)")])])])],-1),l("p",null,[d("参考："),l("a",{href:"https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noreferrer"},"代码随想录")],-1)])]),"main-header":n(()=>[u(t.$slots,"main-header")]),"main-header-after":n(()=>[u(t.$slots,"main-header-after")]),"main-nav":n(()=>[u(t.$slots,"main-nav")]),"main-content":n(()=>[u(t.$slots,"main-content")]),"main-content-after":n(()=>[u(t.$slots,"main-content-after")]),"main-nav-before":n(()=>[u(t.$slots,"main-nav-before")]),"main-nav-after":n(()=>[u(t.$slots,"main-nav-after")]),comment:n(()=>[u(t.$slots,"comment")]),footer:n(()=>[u(t.$slots,"footer")]),aside:n(()=>[u(t.$slots,"aside")]),"aside-custom":n(()=>[u(t.$slots,"aside-custom")]),default:n(()=>[u(t.$slots,"default")]),_:3},8,["frontmatter"])}}};export{w as default};
