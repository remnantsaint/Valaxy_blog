import{_ as d}from"./ValaxyMain.vue_vue_type_style_index_0_lang-Lj6vZGyG.js";import{u as g,c as m,o as u,w as a,r as e,g as s,h as i,f as c,p as k}from"./app-D6Hejker.js";import"./YunFooter-BsWuc4uy.js";import"./YunCard.vue_vue_type_script_setup_true_lang-DrznGDEn.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-Dma2ZTu7.js";import"./post-C0fFnzag.js";const D={__name:"迭代-递归-分治",setup(E,{expose:o}){const l=JSON.parse('{"title":"迭代&递归&分治","description":"","frontmatter":{"categories":["算法基础"],"cover":null,"date":"2023-04-02 20:02:43","image":null,"layout":"post","tags":null,"time_warning":true,"title":"迭代&递归&分治","top":null},"headers":[],"relativePath":"pages/posts/迭代-递归-分治.md","path":"/home/runner/work/remnantsaint.github.io/remnantsaint.github.io/pages/posts/迭代-递归-分治.md","lastUpdated":1758348498000}'),r=g(),n=l.frontmatter||{};return r.meta.frontmatter=Object.assign(r.meta.frontmatter||{},l.frontmatter||{}),k("pageData",l),k("valaxy:frontmatter",n),globalThis.$frontmatter=n,o({frontmatter:{categories:["算法基础"],cover:null,date:"2023-04-02 20:02:43",image:null,layout:"post",tags:null,time_warning:!0,title:"迭代&递归&分治",top:null}}),(t,h)=>{const p=d;return u(),m(p,{frontmatter:c(n)},{"main-content-md":a(()=>[...h[0]||(h[0]=[s("h4",{id:"迭代",tabindex:"-1"},[i("迭代 "),s("a",{class:"header-anchor",href:"#迭代","aria-label":'Permalink to "迭代"'},"​")],-1),s("p",null,"1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。 2.在代码中表现为在一个循环内，不断循环最终得到结果。",-1),s("h4",{id:"递归",tabindex:"-1"},[i("递归 "),s("a",{class:"header-anchor",href:"#递归","aria-label":'Permalink to "递归"'},"​")],-1),s("p",null,[i("1.定义：递归在数学和计算机科学中指在函数的定义中使用函数自身的方法，还额外指一种通过重复将问题分解为同类子问题而解决问题的方法。基本思想是某个函数直接或间接地调用自身，在求解过程中只需关注如何把原问题划分成符合条件的子问题，不需要过分关注子问题如何解决。 2.特征："),s("strong",null,"结束条件"),i("和"),s("strong",null,"自我调用"),i("，示例概括代码如下：")],-1),s("div",{style:{"max-height":"300px"},class:"language-c++ vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"c++"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[s("code",{"v-pre":""},[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," func"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(传入数值)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    if"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," (终止条件)")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        return"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," 最小子问题解;")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    return"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," func"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(缩小规模);")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),s("button",{class:"collapse"})],-1),s("p",null,"3.缺点：在程序执行中，递归是利用堆栈实现的，每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧，递归层数过多会栈溢出。简单的递归不会消耗空间，比如给出链表头，计算长度的递归代码：",-1),s("div",{style:{"max-height":"300px"},class:"language-c++ vp-adaptive-theme"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"c++"),s("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[s("code",{"v-pre":""},[s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," size_recursion"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"Node"),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," *"),s("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"head"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    if"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," (head "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"=="),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," nullptr"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"        return"),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    return"),s("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," size_recursion"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(head->next) "),s("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"+"),s("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 1"),s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";"),s("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"//有一个结点加一次1")]),i(`
`),s("span",{class:"line"},[s("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),s("button",{class:"collapse"})],-1),s("h4",{id:"分治",tabindex:"-1"},[i("分治 "),s("a",{class:"header-anchor",href:"#分治","aria-label":'Permalink to "分治"'},"​")],-1),s("p",null,"1.定义：把一个复杂问题分成多个相同或相似的子问题，直到最后子问题都可以直接求解，原问题即子问题的解的合并。分治问题能通过递归算法解决，也能通过非递归算法解决，通常用递归算法 2.过程：",-1),s("ul",null,[s("li",null,"分解原问题为结构相同的子问题"),s("li",null,"分解到某个容易求解的边界之后，进行递归求解"),s("li",null,"将子问题的解合并成原问题的解 3.能解决的问题特征："),s("li",null,"该问题的规模缩小到一定程度就可以容易地解决"),s("li",null,"该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并成该问题的解"),s("li",null,[i("该问题所分解出的各个子问题是"),s("strong",null,"相互独立"),i("的，即子问题之间不包含公共的子问题。(若子问题不相互独立，一般用动态规划) 4.分治与递归的区别：递归是一种变成技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体的算法思想。")])],-1),s("p",null,[i("参考：   "),s("a",{href:"https://oi.wiki",target:"_blank",rel:"noreferrer"},"https://oi.wiki")],-1)])]),"main-header":a(()=>[e(t.$slots,"main-header")]),"main-header-after":a(()=>[e(t.$slots,"main-header-after")]),"main-nav":a(()=>[e(t.$slots,"main-nav")]),"main-content":a(()=>[e(t.$slots,"main-content")]),"main-content-after":a(()=>[e(t.$slots,"main-content-after")]),"main-nav-before":a(()=>[e(t.$slots,"main-nav-before")]),"main-nav-after":a(()=>[e(t.$slots,"main-nav-after")]),comment:a(()=>[e(t.$slots,"comment")]),footer:a(()=>[e(t.$slots,"footer")]),aside:a(()=>[e(t.$slots,"aside")]),"aside-custom":a(()=>[e(t.$slots,"aside-custom")]),default:a(()=>[e(t.$slots,"default")]),_:3},8,["frontmatter"])}}};export{D as default};
