{"_attachments":{},"_id":"scripting-tools","_rev":"1762696-61f45cb4f614770c6c526ee0","author":{"name":"Joseph Garrone"},"description":"A toolbox that help scripting with Node.","dist-tags":{"latest":"0.19.16"},"license":"MIT","maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"name":"scripting-tools","readme":"# scripting-tools\r\n\r\nA toolbox that help scripting with Node.\r\n\r\nIt is mainly a proxy to ``child_process``.\r\n\r\n\r\n````typescript\r\n/**\r\n * After this function is called every call to execSync\r\n * or exec will print the unix commands being executed.\r\n * */\r\nexport declare function enableCmdTrace(): void;\r\nexport declare function get_uid(unix_user: string): number;\r\nexport declare function get_gid(unix_user: string): number;\r\nexport declare function colorize(str: string, color: \"GREEN\" | \"RED\" | \"YELLOW\"): string;\r\n/**\r\n *\r\n * The stderr is forwarded to the console realtime.\r\n *\r\n * The returned value is the concatenated data received on stdout.\r\n *\r\n * If the return code of the cmd is not 0 an exception is thrown\r\n * and the message cmd + the concatenated data received on stderr.\r\n *\r\n * If enableTrace() have been called the command called will be printed.\r\n *\r\n */\r\nexport declare function execSync(cmd: string, options?: child_process.ExecSyncOptions): string;\r\n/**\r\n *\r\n * The cmd is printed before execution\r\n * stdout and stderr are forwarded to the console realtime.\r\n * Return nothing.\r\n *\r\n * stdio is set to \"inherit\" and thus should not be redefined.\r\n *\r\n */\r\nexport declare function execSyncTrace(cmd: string, options?: child_process.ExecSyncOptions): void;\r\n/**\r\n *\r\n * Like execSync but stderr is not forwarded.\r\n * WARNING: If mean that when the cmd return 0\r\n * all data that may have been wrote on stderr\r\n * are lost into oblivion.\r\n *\r\n * stdio is set to \"pipe\" and thus should not be redefined.\r\n *\r\n */\r\nexport declare function execSyncQuiet(cmd: string, options?: child_process.ExecSyncOptions): string;\r\n/** Same as execSync but async */\r\nexport declare function exec(cmd: string, options?: child_process.ExecOptions): Promise<string>;\r\n/**\r\n * Spawn a process that continue running after current process exit.\r\n * This process will be ignored by stopSubProcessesAsapSync.\r\n * If a logfile_path if provided stdout and stderr will be redirected to this file.\r\n *\r\n * detached, and stdio options should not be set as they are set internally.\r\n * */\r\nexport declare function spawnAndDetach(command: string, args?: ReadonlyArray<string>, options?: child_process.SpawnOptions, logfile_path?: string): child_process.ChildProcess;\r\n/**\r\n *\r\n * Print a message and enable a moving loading bar.\r\n * WARNING: Nothing should be printed to stdout until we stop showing the moving loading.\r\n *\r\n * returns:\r\n * -exec: A proxy to the exec fnc that will call onError before it throw the error.\r\n * -onSuccess: Stop showing the moving loading and pretty print a success message (\"ok\" by default)\r\n * -onError: Stop showing the moving loading and pretty print error message.\r\n *\r\n */\r\nexport declare function start_long_running_process(message: string): {\r\n    exec: typeof exec;\r\n    onSuccess(message?: string): void;\r\n    onError(errorMessage: string): void;\r\n};\r\n/**\r\n * Apt package if not already installed,\r\n * if prog is provided and prog is in the PATH the package will not be installed\r\n * */\r\nexport declare function apt_get_install_if_missing(package_name: string, prog?: string): Promise<void>;\r\nexport declare namespace apt_get_install_if_missing {\r\n    function isPkgInstalled(package_name: string): boolean;\r\n    function doesHaveProg(prog: string): boolean;\r\n}\r\n/** Install or upgrade package via APT */\r\nexport declare function apt_get_install(package_name: string): Promise<void>;\r\nexport declare namespace apt_get_install {\r\n    let isFirst: boolean;\r\n    function record_installed_package(file_json_path: string, package_name: string): void;\r\n    let onError: (error: Error) => never;\r\n    let onInstallSuccess: (package_name: string) => void;\r\n}\r\nexport declare function exit_if_not_root(): void;\r\n/**\r\n *\r\n * Locate a given module in a node_modules directory.\r\n * If the module is required in different version and thus\r\n * present multiple times will be returned the shorter path.\r\n * This ensure that if a given module is in package.json 's dependencies\r\n * section the returned path will be the one we looking for.\r\n *\r\n * @param module_name The name of the module.\r\n * @param module_dir_path Path to the root of the module ( will search in ./node_modules ).\r\n *\r\n * Throw if the module is not found.\r\n *\r\n */\r\nexport declare function find_module_path(module_name: string, module_dir_path: string): string;\r\n/**\r\n *\r\n * Test if two file of folder are same.\r\n * Does not consider stat ( ownership and permission ).\r\n * transparent handling of symlinks.\r\n *\r\n * Example\r\n *\r\n * /foo1/bar/file.txt\r\n * /foo2/bar/file.txt\r\n *\r\n * to compare the two version of file.txt\r\n * call with \"/foo1\", \"/foo2\", \"./bar/file.txt\";\r\n * or with \"/foo1/bar/file.txt\", \"/foo2/bar/file.txt\"\r\n *\r\n * @param relative_from_path1 absolute path ex: '/foo1'\r\n * @param relative_from_path2 absolute path ex: '/foo2'\r\n * @param relative_to_path relative path ex: './bar/file.txt\" or 'bar/file.txt'\r\n * for convenience relative_to_path can be absolute as long as it has relative_from_path1\r\n * or relative_from_path2 as parent.\r\n *\r\n */\r\nexport declare function fs_areSame(relative_from_path1: string, relative_from_path2: string, relative_to_path?: string): boolean;\r\nexport declare namespace fs_areSame {\r\n    function get_relative_to_path(dir_path1: string, dir_path2: string, to_path: string): string;\r\n}\r\n/**\r\n *\r\n * Move or copy file of folder.\r\n * -If dest is identical to source nothing is copied nor moved.\r\n * -If dest exist and is different of source it will be deleted prior to proceeding with action.\r\n * -In move mode if dest identical to source source will be removed.\r\n * -When copy is effectively performed the stat are conserved.\r\n * -If dirname of dest does not exist in fs, it will be created.\r\n * -Unlike cp or mv \"/src/file.txt\" \"/dest\" will NOT place file.txt in dest but dest will become file.txt\r\n *\r\n * calling [action] \"/src/foo\" \"/dst/foo\" is equivalent\r\n * to calling [action] \"/src\" \"/dst\" \"./foo\" ( or \"foo\" )\r\n * or [action] \"/src\" \"/dst\" \"src/foo\"\r\n * or [action] \"/src\" \"/dst\" \"dst/foo\"\r\n *\r\n */\r\nexport declare function fs_move(action: \"COPY\" | \"MOVE\", relative_from_path_src: string, relative_from_path_dest: string, relative_to_path?: string): void;\r\n/**\r\n * Download and extract a tarball. throws web_get.DownloadError and Error\r\n *\r\n * Example\r\n *\r\n * website.com/rel.tar.gz\r\n * ./file1.txt\r\n * ./dir/file2.txt\r\n *\r\n * /foo/\r\n * ./file3.txt\r\n * ./dir/file4.txt\r\n *\r\n * calling with \"website.com/rel.tar.gz\", \"MERGE\" will result in:\r\n *\r\n * /foo/\r\n * ./file1.txt\r\n * ./file3.txt\r\n * ./dir/file4.txt\r\n *\r\n * calling with \"website.com/rel.tar.gz\", \"OVERWRITE IF EXIST\" will result in:\r\n *\r\n * /foo/\r\n * ./file1.txt\r\n * ./dir/file2.txt\r\n *\r\n */\r\nexport declare function download_and_extract_tarball(url: string, dest_dir_path: string, mode: \"MERGE\" | \"OVERWRITE IF EXIST\"): Promise<void>;\r\n/** 10s of inactivity will trigger timeout, throws DownloadError only */\r\nexport declare function web_get(url: string, file_path: string): Promise<void>;\r\nexport declare function web_get(url: string): Promise<string>;\r\nexport declare namespace web_get {\r\n    class DownloadError extends Error {\r\n        readonly url: string;\r\n        readonly cause: \"CONNECTION ERROR\" | \"INCOMPLETE\" | \"HTTP ERROR CODE\";\r\n        constructor(url: string, cause: \"CONNECTION ERROR\" | \"INCOMPLETE\" | \"HTTP ERROR CODE\", message: string);\r\n    }\r\n    class DownloadErrorIncomplete extends DownloadError {\r\n        readonly contentLength: number | undefined;\r\n        readonly receivedBytes: number;\r\n        constructor(url: string, contentLength: number | undefined, receivedBytes: number, info?: string);\r\n    }\r\n    class DownloadErrorHttpErrorCode extends DownloadError {\r\n        readonly code: number;\r\n        constructor(url: string, code: number);\r\n    }\r\n}\r\nexport declare function fs_ls(dir_path: string, mode?: \"FILENAME\" | \"ABSOLUTE PATH\", showHidden?: boolean): string[];\r\n/**\r\n *\r\n * Create a symbolic link.\r\n * If dst exist it is removed.\r\n * directories leading to dest are created if necessary.\r\n *\r\n */\r\nexport declare function createSymlink(src_path: string, dst_path: string): void;\r\n/** Create a executable file */\r\nexport declare function createScript(file_path: string, content: string): void;\r\nexport declare namespace unixUser {\r\n    function create(unix_user: string, home_dir_path?: string): void;\r\n    function remove(unix_user: string): void;\r\n}\r\nexport { get_caller_file_path } from \"./get_caller_file_path\";\r\n/**\r\n *\r\n * Equivalent to the pattern $() in bash.\r\n * Strip final LF if present.\r\n * If cmd fail no error is thrown, an empty string is returned.\r\n * Does not print to stdout.\r\n *\r\n * Typical usage: uname -r or which pkill\r\n *\r\n */\r\nexport declare function sh_eval(cmd: string): string;\r\n/**\r\n * Run a command and return true if the return code was 0.\r\n * Does not print to stdout.\r\n */\r\nexport declare function sh_if(cmd: string): boolean;\r\n/**\r\n * Return a promise that resolve as the source promise when fulfilled\r\n * or resolve with the error when reject.\r\n * If a timeout is specified the returned promise resolve with an error after [timeout]ms\r\n * if the source promise did not completed before.\r\n * The message of the timeout error is safePr.timeoutErrorMessage\r\n */\r\nexport declare function safePr<T>(pr: Promise<T>, timeout?: number): Promise<T | Error>;\r\nexport declare namespace safePr {\r\n    const timeoutErrorMessage = \"safePr timeout\";\r\n}\r\n/**\r\n *\r\n * Allow to schedule action function to perform before exiting.\r\n *\r\n * The task function will always be called before the process stop\r\n * unless process.exit is explicitly called somewhere or\r\n * if the process receive any signal other than the ones specified\r\n * in the ExitCause.Signal[\"signal\"] type.\r\n *\r\n * The process may stop for tree reasons:\r\n * 1) If there is no more work scheduled ( natural termination ).\r\n * 2) If an uncaught exception it thrown ( or a unhandled promise rejection )\r\n * 3) If a signal ( one of the handled ) is sent to the process.\r\n *\r\n * To manually exit the process there is two option:\r\n * - Call process.exit(X) but the task function will not be called.\r\n * - Emit \"beforeExit\" on process object ( process.emit(\"beforeExit, process.exitCode= X) );\r\n *  Doing so you simulate 1st stop condition ( natural termination ).\r\n *\r\n * To define the return code set process.exitCode. The exit code can be set\r\n * before emitting \"beforeExit\" or in the task function.\r\n * If exitCode has not be defined the process will exit with 0 if\r\n * there was nothing else to do and 1 otherwise.\r\n *\r\n * The task function can be synchronous or asynchronous.\r\n * The task function has [timeout] ms to complete.\r\n * If it has not completed within this delay the process will\r\n * be terminated anyway. (Default 4000 ms )\r\n * Setting [timeout] to a negative value will disable the timer.\r\n * WARNING: It is important not to perform sync operation that can\r\n * hang for a long time in the task function ( e.g. execSync(\"sleep 1000\"); )\r\n * because while the sync operation are performed the timeout can't be triggered.\r\n *\r\n * As soon as the task function is called all the other exitCause that\r\n * may auccur will be ignored so that the task function have time to complete.\r\n * Anyway the task function is called only once.\r\n *\r\n * Whether the task function complete by successfully or throw\r\n * an exception the process will terminate with exit code set\r\n * in process.exitCode at the time of the completion.\r\n *\r\n * Provide shouldExitIf function to filter what should be\r\n * considered a case to terminate the process.\r\n * Only exception and supported signals can be bypassed,\r\n * Nothing else to do will always terminate the process.\r\n * By default exiting on any signal or uncaught errors.\r\n *\r\n * Before exiting all subprocess will be killed.\r\n *\r\n *\r\n */\r\nexport declare function setProcessExitHandler(task: (exitCause: setProcessExitHandler.ExitCause) => any, timeout?: number, shouldExitIf?: (exitCause: Exclude<setProcessExitHandler.ExitCause, setProcessExitHandler.ExitCause.NothingElseToDo>) => boolean): void;\r\nexport declare namespace setProcessExitHandler {\r\n    type ExitCause = ExitCause.Signal | ExitCause.Exception | ExitCause.NothingElseToDo;\r\n    namespace ExitCause {\r\n        type Signal = {\r\n            type: \"SIGNAL\";\r\n            signal: keyof typeof Signal._obj;\r\n        };\r\n        namespace Signal {\r\n            const _obj: {\r\n                \"SIGINT\": null;\r\n                \"SIGUSR2\": null;\r\n                \"SIGHUP\": null;\r\n            };\r\n            const list: Signal[\"signal\"][];\r\n        }\r\n        type Exception = {\r\n            type: \"EXCEPTION\";\r\n            error: Error;\r\n        };\r\n        type NothingElseToDo = {\r\n            type: \"NOTHING ELSE TO DO\";\r\n        };\r\n    }\r\n    let log: typeof console.log;\r\n}\r\n/**\r\n *\r\n * Stop a process by sending a specific signal to a target process.\r\n * When the function return the main process and all it's descendent processes are terminated.\r\n *\r\n * The default signal is SIGUSR2 which is the signal used to gracefully terminate\r\n * Process created by the createService function.\r\n *\r\n * Optionally runfiles_path can be provided to define a set of files\r\n * that should be suppressed before returning.\r\n *\r\n * If pid is provided under the form of a pidfile path it will\r\n * be added to the runfiles set.\r\n *\r\n * If all the processes does not terminate within [delay_before_sigkill]ms\r\n * (default 50000) then KILL signal will be sent to all processes still alive.\r\n *\r\n * If the PID provided is the same that the PID of the process running the function\r\n * PidMatchCurrentProcessError will be thrown.\r\n *\r\n */\r\nexport declare function stopProcessSync(pidfile_path_or_pid: string | number, signal?: NodeJS.Signals, delay_before_sigkill?: number, runfiles_path?: string[]): void;\r\nexport declare namespace stopProcessSync {\r\n    class PidMatchCurrentProcessError extends Error {\r\n        readonly cleanupRunfiles: () => void;\r\n        constructor(cleanupRunfiles: () => void);\r\n    }\r\n    /**\r\n     * Stopping process As Soon As Possible,\r\n     * stopProcessSync with signal SIGKILL and timeout 0\r\n     * */\r\n    function stopProcessAsapSync(pidfile_path_or_pid: string | number, runfiles_path?: string[]): void;\r\n    /**\r\n     * Terminate all child process of current process ASAP.\r\n     *\r\n     * NOTE: Directly after this function ( in the current tick )\r\n     * direct parents process that had sub processes will be Zombies.\r\n     * However they will be reaped by the current process on next tick.\r\n     *\r\n     */\r\n    function stopSubProcessesAsapSync(): void;\r\n    namespace stopSubProcessesAsapSync {\r\n        const ignorePids: Set<number>;\r\n    }\r\n    /** Invoke kill, can't throw */\r\n    function kill(pid: number, signal: NodeJS.Signals): void;\r\n    /**\r\n     * Get the list of subprocess of a process ( return a list of pid )\r\n     */\r\n    function getSubProcesses(pid: number, depth: \"FULL PROCESS TREE\" | \"DIRECT SUB PROCESSES ONLY\"): number[];\r\n    /** Return true only if exist and is not a daemon */\r\n    function isProcessRunning(pid: number): boolean;\r\n    /** Debug function to print the process tree of the current process. */\r\n    function _printProcessTree(log?: typeof console.log): void;\r\n    let log: typeof console.log;\r\n}\r\n/**\r\n *\r\n * Function to create the entry point (main.js) of a node service that can:\r\n * -Restart on crash (without relying on systemd to do so).\r\n * -Execute as specific unix user but can perform tasks as root before start.\r\n * -Be stopped gracefully by sending USR2 signal on the root process ( identified by pidfile ).\r\n * -Be started via a shell and gracefully stopped with CTRL-C (INT signal).\r\n * -Ensure only one instance of the service run at the same time.\r\n *      ( if at the time the main is called there is an other instance of the service\r\n *      running it is gracefully terminated )\r\n * -Ensure that the process will terminate in at most [ stop_timeout ] ms after\r\n *      receiving INT or USR2 signal. (default 5second)\r\n * -Forward daemon processes stdout to root process stdout.\r\n * -Can fork multiple daemon process.\r\n *\r\n * The root process forward command line arguments and environnement variable to\r\n * the daemon processes.\r\n *\r\n * => rootProcess function should return ( when not default ):\r\n * -pidfile_path: where to store the pid of the root process.\r\n *      take to terminate after requested to exit gracefully.\r\n * -srv_name: Name of the service to overwrite the process names. (Default: not overwriting)\r\n * -stop_timeout: The maximum amount of time ( in ms ) the\r\n *      that beforeExitTask can take to complete before being killed by force by root process.\r\n *      After receiving USR2 signal or CTRL, the root process will be closed within [trop_timeout]+1000ms\r\n * -assert_unix_user: enforce that the main be called by a specific user.\r\n * -isQuiet?: set to true to disable process debug info logging on stdout. Prefixed by [ service ]. ( default false )\r\n * -doForwardDaemonStdout?: set to true to forward everything the daemon\r\n *      process write to stdout to the root process stdout. ( default true )\r\n * -daemon_unix_user?: User who should own the daemon process.\r\n * -daemon_node_path?: Node.js executable that should be used to by the daemon process.\r\n * -daemon_cwd?: working directory of the daemon process.\r\n * -daemon_restart_after_crash_delay?: ( Default to 500ms. )Delay in ms before restarting the daemon\r\n *      after it terminate without being requested to. If set to a negative number the daemons\r\n *      will not be restarted after it terminate for the first time and :\r\n *      If all daemons process exited with 0 and there is no other daemon process the root process\r\n *      will end with a clean exit code.\r\n *      If any of the daemon exit with an unclean code the root process will be terminated with an error code\r\n *      even if there is some other daemon running.\r\n * -daemon_count: Number of instance of daemon process that should be forked, default 1.\r\n * -max_consecutive_restart: Number of time a daemon should be restarted after crashing right after start.\r\n *      (Default ~Infinity).\r\n * -preForkTask: Task to perform before forking a daemon process.\r\n *      It is called just before forking the daemon process. ( called again on every restart. )\r\n *      If the function is async the daemon will not be forked until the returned promise resolve.\r\n *      If the function throw exception root process will exit with code 1.\r\n *      (pidfile will be deleted)\r\n *      If the function is async and if it need to spawn child processes then\r\n *      an implementation for terminateSubProcess ( passed as reference ) should be provided so that\r\n *      if when called it kill all the child processes then resolve once they are terminated.\r\n *      The to which the promise resolve will be used as exit code for the root process.\r\n *      Note that terminateSubProcess should never be called, it is a OUT parameter.\r\n *      However if the implementation provided is just to send a SIGKILL to the forked processes\r\n *      then there is no need to provide an implementation as all the root process's sub processes tree\r\n *      will be killed before exiting anyway.\r\n *\r\n * => daemonProcess\r\n * It should return:\r\n * -launch: the function that the daemon process need to call to start the actual job that the service is meant to perform.\r\n * -beforeExitTask: function that should be called before the daemon process exit. ( e.g. creating crash report ).\r\n *      If the daemon process is terminating due to an error the error will be passed as argument.\r\n *      There is two scenario that will led to this function NOT being called:\r\n *      1)The daemon process receive KILL or other deadly signal that can't be overridden.\r\n *      2)The root process terminate.\r\n * daemon_number represent the instance index of the daemon among the total of [damon_count] process forked.\r\n * It can be user to use a different logfile for each daemon process instance.\r\n *\r\n * NOTE: If the root process receive a deadly signal other than INT, USR2 or HUP\r\n * ( e.g. KILL or STOP ) the root and daemon processes will immediately terminate without\r\n * executing beforeExit tasks or removing pidfile.\r\n *\r\n * NOTE: because setting listener on \"message\" and \"disconnect\" process event prevent the\r\n * thread from terminating naturally where is nothing more to do if you wish to manually\r\n * terminate the daemon process without termination being requested from the parent you can:\r\n *        1) emit \"beforeExit\" on process setting the desired exit code ( process.emit(\"beforeExit\", process.exitCode= X);\r\n *        2) throw an exception.\r\n *\r\n */\r\nexport declare function createService(params: {\r\n    rootProcess(): Promise<{\r\n        pidfile_path: string;\r\n        srv_name?: string;\r\n        stop_timeout?: number;\r\n        assert_unix_user?: string;\r\n        isQuiet?: boolean;\r\n        doForwardDaemonStdout?: boolean;\r\n        daemon_unix_user?: string;\r\n        daemon_node_path?: string;\r\n        daemon_cwd?: string;\r\n        daemon_restart_after_crash_delay?: number;\r\n        daemon_count?: number;\r\n        max_consecutive_restart?: number;\r\n        preForkTask?: (terminateChildProcesses: {\r\n            impl: () => Promise<void>;\r\n        }, daemon_number: number) => Promise<void> | void;\r\n    }>;\r\n    daemonProcess(daemon_number: number, daemon_count: number): Promise<{\r\n        launch: () => any;\r\n        beforeExitTask?: (error: Error | undefined) => Promise<void> | void;\r\n    }>;\r\n}): void;\r\n\r\nexport declare namespace systemd {\r\n    /**\r\n     * Generate a systemd config file for a service created via \"createService\" function\r\n     * enable by default, start by default.\r\n     */\r\n    function createConfigFile(srv_name: string, main_js_path: string, node_path?: string, enable?: \"ENABLE\" | false, start?: \"START\" | false): void;\r\n    /** Remove config file disable and reload daemon, never throw, stop is false by default */\r\n    function deleteConfigFile(srv_name: string, stop?: false | \"STOP\"): void;\r\n}\r\n\r\n````","time":{"created":"2022-01-28T21:14:28.780Z","modified":"2024-05-04T16:38:33.494Z","0.19.13":"2020-08-16T17:42:59.001Z","0.19.12":"2020-05-17T23:46:10.950Z","0.19.11":"2020-05-17T23:40:43.599Z","0.19.10":"2020-05-17T23:36:13.393Z","0.19.14":"2022-09-14T00:46:01.417Z","0.19.15":"2024-02-29T21:24:40.885Z","0.19.16":"2024-05-04T16:38:22.655Z"},"versions":{"0.19.13":{"name":"scripting-tools","version":"0.19.13","description":"A toolbox that help scripting with Node.","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"gitHead":"bdcb2827397e07b8455f53fd82c901b44c6bd793","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_id":"scripting-tools@0.19.13","_npmVersion":"6.4.1","_nodeVersion":"10.20.1","_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"dist":{"shasum":"836df7d9c2ec99aea91984d1d5b2bd110670afec","size":48089,"noattachment":false,"tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.13.tgz","integrity":"sha512-d09H8vzSVa8p4XUTJqHZDbjKDyl5TG3SyPfNPUUkfyOwjwykStmfK8AXyWq7VRWjcgzTpkTiJ9uMk1NytMQY7w=="},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.13_1597599778850_0.6227520913546618"},"_hasShrinkwrap":false,"publish_time":1597599779001,"_cnpm_publish_time":1597599779001,"_cnpmcore_publish_time":"2021-12-16T22:58:16.421Z"},"0.19.12":{"name":"scripting-tools","version":"0.19.12","description":"A toolbox that help scripting with Node.","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"gitHead":"dad6510f12de9caaeed631031bf49178ca6aeea0","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_id":"scripting-tools@0.19.12","_npmVersion":"6.4.1","_nodeVersion":"10.19.0","_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"dist":{"shasum":"3e63bc396f8f405907191d9982171ecb3d01100f","size":48119,"noattachment":false,"tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.12.tgz","integrity":"sha512-EFzjnGAZ/w2jdX8zxV2annB2yyaW2cih1jCqim0N1PgVGc1+k+QhIuHGpDVnAIcGXUywBk+JON5GQDkKP8QHyQ=="},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.12_1589759170760_0.24481840368633345"},"_hasShrinkwrap":false,"publish_time":1589759170950,"_cnpm_publish_time":1589759170950,"_cnpmcore_publish_time":"2021-12-16T22:58:17.133Z"},"0.19.11":{"name":"scripting-tools","version":"0.19.11","description":"Tools to build shell scripts with node","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"gitHead":"528e279109df690afab07f601ef3084ad229d04c","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_id":"scripting-tools@0.19.11","_npmVersion":"6.4.1","_nodeVersion":"10.19.0","_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"dist":{"shasum":"8bf1d73ad16b236f7370a307bfbfa8e521d2e928","size":48079,"noattachment":false,"tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.11.tgz","integrity":"sha512-OQ4Pd1GTCK229pk/yJML/0h/H8p60VhZUrLsnHN3mlCE1hxAP+aoU2ZHwP15p6qov1NrYhxLsBbkjh7eo8glMw=="},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.11_1589758843464_0.37824939214485664"},"_hasShrinkwrap":false,"publish_time":1589758843599,"_cnpm_publish_time":1589758843599,"_cnpmcore_publish_time":"2021-12-16T22:58:17.414Z"},"0.19.10":{"name":"scripting-tools","version":"0.19.10","description":"Tools to build shell scripts with node","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"gitHead":"258f4d6722762a8cf25130db7650f114670a26a6","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_id":"scripting-tools@0.19.10","_npmVersion":"6.4.1","_nodeVersion":"10.19.0","_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"dist":{"shasum":"50a0b979cb5eed9682811ae92650f95ef0080f14","size":48095,"noattachment":false,"tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.10.tgz","integrity":"sha512-YXiqJEhvPrZ6nq4Y+lGQqtkTk8W4aoyX8QsHM3TvuoWcJTwB062/g8zDe4hq44zBnlnVEtoQkbvd0GC5vVNrMQ=="},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.10_1589758573233_0.17945654692343638"},"_hasShrinkwrap":false,"publish_time":1589758573393,"_cnpm_publish_time":1589758573393,"_cnpmcore_publish_time":"2021-12-16T22:58:17.716Z"},"0.19.14":{"name":"scripting-tools","version":"0.19.14","description":"A toolbox that help scripting with Node.","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"gitHead":"53627eb26dadec2ce58be480336483021c54341a","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_id":"scripting-tools@0.19.14","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-KGRES70dEmcaCdpx3R88bLWmfA4mQ/EGikCQy0FGTZwx3y9F5yYkzEhwp02+ZTgpvF25JcNOhDBbOqL6z92kwg==","shasum":"d46cdea3dcf042b103b1712103b007e72c4901d5","tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.14.tgz","fileCount":16,"unpackedSize":216200,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCChQqM//Kk8VUL4Lakbbo2R1W/AeakK4stHyOS65a3cwIhALRY7NWZ+EG1jmlldWyaRwoHxk9nxSjCpN3WQoiAnPIY"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjISRJACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmropg//Rc3C3x1MuoGDyM4rTJQYNpT4qkm3zVNzqZryXQBEgxkIOMPN\r\nPjMK0yNj6nrMjif+LgYCrgvW38U/wgOdZZSpBKdikaF6Uz49hTtjWSFWtWjc\r\nV93VqPB9r84K2oMkTIopk9qmAXr6/PfKZwEvH5LcOdMuwPBF9Pq+L/QLGy2m\r\nmQSK/UiuUG9LRRu2dxWzqP9WyC2aP/5mz0LcrFEvI4390GWI2FRI6qHIVP94\r\nUvH+nOkVaupu68qhNt3/5auduo8PGXy2YSZuhxbpSD8fouoU+KtauQCrbPqO\r\nWy2Y3CDB4r3HHukyUtDrU+AQWBaXaWrna45z8JoGDY60wvOixUi2WM7Fb+Jw\r\nKAqyz6PHq8J32wBDhKr+K20FccnkPTcxF/56mL8zgXGXOoSajZMR4ugi+6cD\r\nHSyCn+yzU3N4tgLUXSlQLBfZ+0tpG+y82VhhBrWNPhNQi0AFAzJpETlMnYOO\r\nhEfB+qrLov9sF67sOineu8FsLfAR1o1JwypJM0t96taUznLIA0pVcbukBULj\r\n2tC+AZhw+1XTJOILJQDqj5TSaFz7oFPZublVX1mosjdFF64qv1CnrJYle7Sm\r\nggh+gPLsqlP39rprieqex+nw+FlDGOTMY4xC2MN3nL2YmBj5YKdHnGnzTBUL\r\njtbvcerYuAnpjIlhTmF352kt6cy3LRn32zI=\r\n=MXmZ\r\n-----END PGP SIGNATURE-----\r\n","size":46535},"_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"directories":{},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.14_1663116361140_0.3053922918344243"},"_hasShrinkwrap":false,"_cnpmcore_publish_time":"2022-09-14T00:46:21.977Z"},"0.19.15":{"name":"scripting-tools","version":"0.19.15","description":"A toolbox that help scripting with Node.","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"_id":"scripting-tools@0.19.15","gitHead":"f25782d8a49b41e64c5c67234e932052328d12d1","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_nodeVersion":"20.6.1","_npmVersion":"9.8.1","dist":{"integrity":"sha512-9PW93z7BTFSma1zPcv/n3r2c+VJDcMsxzLdA924kMDav6ua1io8dv+h9aeIJvwKLcS+Y4hDKsX6NRyfq5eLNwQ==","shasum":"6b6bce272681b2e171c2bf92b1499eceddd064b4","tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.15.tgz","fileCount":16,"unpackedSize":216827,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEN8qx1wgPnAyNnnaYbRUNJnzSOb4CQcyaV3AYqIklk9AiEA+l84R9r3wgXaikJK/lVPdgsiyDH9BnOBSQrNzGmAQDY="}],"size":46713},"_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"directories":{},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.15_1709241880661_0.2553586728434767"},"_hasShrinkwrap":false,"_cnpmcore_publish_time":"2024-02-29T21:24:40.885Z","publish_time":1709241880885,"_source_registry_name":"default"},"0.19.16":{"name":"scripting-tools","version":"0.19.16","description":"A toolbox that help scripting with Node.","main":"./dist/lib/index.js","types":"./dist/lib/index.d.ts","scripts":{"tsc":"node ./node_modules/typescript/bin/tsc -p ./tsconfig.json","test":"node dist/test/index"},"repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"author":{"name":"Joseph Garrone"},"license":"MIT","dependencies":{},"devDependencies":{"@types/node":"^8.9.1","typescript":"^3.3.3333"},"_id":"scripting-tools@0.19.16","gitHead":"bc2d7ec1efcb88a8da2baf11aa87717f4da1c90d","bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","_nodeVersion":"20.6.1","_npmVersion":"9.8.1","dist":{"integrity":"sha512-pHapyap/y3K6gOn0CwaKFWCWWFxPJwDeLgXKxbxgTFwBogdIoV+wKpIgpHFPELS6/Fjulf5jCKn3HZX2tFfSQQ==","shasum":"85b16ee0fd44fb115f85d37a65bee44577aeb7af","tarball":"https://registry.npmmirror.com/scripting-tools/-/scripting-tools-0.19.16.tgz","fileCount":16,"unpackedSize":216819,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHQR4lKiPtjtq+jtJrw15EYaqa4yoyE/E7YGEPJbEZfVAiBZUqC8mZPcoBh2wZFmhzE1GveMBffH7WY4o1bCMtLlYA=="}],"size":46704},"_npmUser":{"name":"garronej","email":"joseph.garrone.gj@gmail.com"},"directories":{},"maintainers":[{"name":"garronej","email":"joseph.garrone.gj@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/scripting-tools_0.19.16_1714840702425_0.8523030860445544"},"_hasShrinkwrap":false,"_cnpmcore_publish_time":"2024-05-04T16:38:22.655Z","publish_time":1714840702655,"_source_registry_name":"default"}},"bugs":{"url":"https://github.com/garronej/scripting-tools/issues"},"homepage":"https://github.com/garronej/scripting-tools#readme","repository":{"type":"git","url":"git+https://github.com/garronej/scripting-tools.git"},"_source_registry_name":"default"}