{"_attachments":{},"_id":"liftup","_rev":"4728-61f150f2963ca28f5ee520aa","author":{"name":"Grunt Development Team","url":"https://gruntjs.com/development-team"},"description":"Launch your command line tool with ease.","dist-tags":{"latest":"3.0.1"},"license":"MIT","maintainers":[{"name":"vladikoff","email":"vlad@vladikoff.com"}],"name":"liftup","readme":"# liftup\n\n## Fork of https://github.com/js-cli/js-liftoff since version 2.2.1\n\n> Launch your command line tool with ease.\n\n[![NPM](https://nodei.co/npm/liftup.png)](https://nodei.co/npm/liftup/)\n\n## What is it?\n[See this blog post](http://weblog.bocoup.com/building-command-line-tools-in-node-with-liftoff/), [check out this proof of concept](https://github.com/js-cli/js-hacker), or read on.\n\nSay you're writing a CLI tool.  Let's call it [hacker](https://github.com/js-cli/js-hacker).  You want to configure it using a `Hackerfile`.  This is node, so you install `hacker` locally for each project you use it in.  But, in order to get the `hacker` command in your PATH, you also install it globally.\n\nNow, when you run `hacker`, you want to configure what it does using the `Hackerfile` in your current directory, and you want it to execute using the local installation of your tool.  Also, it'd be nice if the `hacker` command was smart enough to traverse up your folders until it finds a `Hackerfile`&mdash;for those times when you're not in the root directory of your project.  Heck, you might even want to launch `hacker` from a folder outside of your project by manually specifying a working directory.  Liftoff manages this for you.\n\nSo, everything is working great.  Now you can find your local `hacker` and `Hackerfile` with ease.  Unfortunately, it turns out you've authored your `Hackerfile` in coffee-script, or some other JS variant.  In order to support *that*, you have to load the compiler for it, and then register the extension for it with node.  Good news, Liftoff can do that, and a whole lot more, too.\n\n## API\n\n### constructor(opts)\n\nCreate an instance of Liftoff to invoke your application.\n\nAn example utilizing all options:\n```js\nconst Hacker = new Liftoff({\n  name: 'hacker',\n  processTitle: 'hacker',\n  moduleName: 'hacker',\n  configName: 'hackerfile',\n  extensions: {\n    '.js': null,\n    '.json': null,\n    '.coffee': 'coffee-script/register'\n  },\n  v8flags: ['--harmony'] // or v8flags: require('v8flags')\n});\n```\n\n#### opts.name\n\nSugar for setting `processTitle`, `moduleName`, `configName` automatically.\n\nType: `String`  \nDefault: `null`\n\nThese are equivalent:\n```js\nconst Hacker = Liftoff({\n  processTitle: 'hacker',\n  moduleName: 'hacker',\n  configName: 'hackerfile'\n});\n```\n```js\nconst Hacker = Liftoff({name:'hacker'});\n```\n\n#### opts.moduleName\n\nSets which module your application expects to find locally when being run.\n\nType: `String`  \nDefault: `null`\n\n#### opts.configName\n\nSets the name of the configuration file Liftoff will attempt to find.  Case-insensitive.\n\nType: `String`  \nDefault: `null`\n\n#### opts.extensions\n\nSet extensions to include when searching for a configuration file.  If an external module is needed to load a given extension (e.g. `.coffee`), the module name should be specified as the value for the key.\n\nType: `Object`  \nDefault: `{\".js\":null,\".json\":null}`\n\n**Examples:**\n\nIn this example Liftoff will look for `myappfile{.js,.json,.coffee}`.  If a config with the extension `.coffee` is found, Liftoff will try to require `coffee-script/require` from the current working directory.\n```js\nconst MyApp = new Liftoff({\n  name: 'myapp',\n  extensions: {\n    '.js': null,\n    '.json': null,\n    '.coffee': 'coffee-script/register'\n  }\n});\n```\n\nIn this example, Liftoff will look for `.myapp{rc}`.\n```js\nconst MyApp = new Liftoff({\n  name: 'myapp',\n  configName: '.myapp',\n  extensions: {\n    'rc': null\n  }\n});\n```\n\nIn this example, Liftoff will automatically attempt to load the correct module for any javascript variant supported by [interpret](https://github.com/js-cli/js-interpret) (as long as it does not require a register method).\n\n```js\nconst MyApp = new Liftoff({\n  name: 'myapp',\n  extensions: require('interpret').jsVariants\n});\n```\n#### opts.v8flags\n\nAny flag specified here will be applied to node, not your program.  Useful for supporting invocations like `myapp --harmony command`, where `--harmony` should be passed to node, not your program. This functionality is implemented using [flagged-respawn](http://github.com/js-cli/js-flagged-respawn). To support all v8flags, see [v8flags](https://github.com/js-cli/js-v8flags).\n\nType: `Array|Function`  \nDefault: `null`\n\nIf this method is a function, it should take a node-style callback that yields an array of flags.\n\n#### opts.processTitle\n\nSets what the [process title](http://nodejs.org/api/process.html#process_process_title) will be.\n\nType: `String`  \nDefault: `null`\n\n#### opts.completions(type)\n\nA method to handle bash/zsh/whatever completions.\n\nType: `Function`  \nDefault: `null`\n\n#### opts.configFiles\n\nAn object of configuration files to find. Each property is keyed by the default basename of the file being found, and the value is an object of [path arguments](#path-arguments) keyed by unique names.\n\n__Note:__ This option is useful if, for example, you want to support an `.apprc` file in addition to an `appfile.js`. If you only need a single configuration file, you probably don't need this. In addition to letting you find multiple files, this option allows more fine-grained control over how configuration files are located.\n\nType: `Object`  \nDefault: `null`\n\n#### Path arguments\n\nThe [`fined`](https://github.com/js-cli/fined) module accepts a string representing the path to search or an object with the following keys:\n\n* `path` __(required)__\n\n  The path to search. Using only a string expands to this property.\n\n  Type: `String`  \n  Default: `null`\n\n* `name`\n\n  The basename of the file to find. Extensions are appended during lookup.\n\n  Type: `String`  \n  Default: Top-level key in `configFiles`\n\n* `extensions`\n\n  The extensions to append to `name` during lookup. See also: [`opts.extensions`](#optsextensions).\n\n  Type: `String|Array|Object`  \n  Default: The value of [`opts.extensions`](#optsextensions)\n\n* `cwd` \n\n  The base directory of `path` (if relative).\n\n  Type: `String`  \n  Default: The value of [`opts.cwd`](#optscwd)\n\n* `findUp`\n\n  Whether the `path` should be traversed up to find the file.\n\n  Type: `Boolean`  \n  Default: `false`\n\n**Examples:**\n\nIn this example Liftoff will look for the `.hacker.js` file relative to the `cwd` as declared in `configFiles`.\n```js\nconst MyApp = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    '.hacker': {\n      cwd: '.'\n    }\n  }\n});\n```\n\nIn this example, Liftoff will look for `.hackerrc` in the home directory.\n```js\nconst MyApp = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    '.hacker': {\n      home: {\n        path: '~',\n        extensions: {\n          'rc': null\n        }\n      }\n    }\n  }\n});\n```\n\nIn this example, Liftoff will look in the `cwd` and then lookup the tree for the `.hacker.js` file.\n```js\nconst MyApp = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    '.hacker': {\n      up: {\n        path: '.',\n        findUp: true\n      }\n    }\n  }\n});\n```\n\nIn this example, the `name` is overridden and the key is ignored so Liftoff looks for `.override.js`.\n```js\nconst MyApp = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    hacker: {\n      override: {\n        path: '.',\n        name: '.override'\n      }\n    }\n  }\n});\n```\n\nIn this example, Liftoff will use the home directory as the `cwd` and looks for `~/.hacker.js`.\n```js\nconst MyApp = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    '.hacker': {\n      home: {\n        path: '.',\n        cwd: '~'\n      }\n    }\n  }\n});\n```\n\n### prepare(opts, callback(env))\n\nPrepares the environment for your application with provided options, and invokes your callback with the calculated environment as the first argument.  The environment can be modified before using it as the first argument to `execute`.\n\n**Example Configuration w/ Options Parsing:**\n\n```js\nconst Liftoff = require('liftoff');\nconst MyApp = new Liftoff({name:'myapp'});\nconst argv = require('minimist')(process.argv.slice(2));\nconst onExecute = function (env, argv) {\n  // Do post-execute things\n};\nconst onPrepare = function (env) {\n  console.log('my environment is:', env);\n  console.log('my liftoff config is:', this);\n  MyApp.execute(env, onExecute);\n};\nMyApp.prepare({\n  cwd: argv.cwd,\n  configPath: argv.myappfile,\n  preload: argv.preload,\n  completion: argv.completion\n}, onPrepare);\n```\n\n**Example w/ modified environment**\n\n```js\nconst Liftoff = require('liftoff');\nconst Hacker = new Liftoff({\n  name: 'hacker',\n  configFiles: {\n    '.hacker': {\n      home: { path: '.', cwd: '~' }\n    }\n  }\n});\nconst onExecute = function (env, argv) {\n  // Do post-execute things\n};\nconst onPrepare = function (env) {\n   env.configProps = ['home', 'cwd'].map(function(dirname) {\n    return env.configFiles['.hacker'][dirname]\n  }).filter(function(filePath) {\n    return Boolean(filePath);\n  }).reduce(function(config, filePath) {\n    return mergeDeep(config, require(filePath));\n  }, {});\n\n  if (env.configProps.hackerfile) {\n    env.configPath = path.resolve(env.configProps.hackerfile);\n    env.configBase = path.dirname(env.configPath);\n  }\n\n  Hacker.execute(env, onExecute);\n};\nHacker.prepare({}, onPrepare);\n```\n\n#### opts.cwd\n\nChange the current working directory for this launch. Relative paths are calculated against `process.cwd()`.\n\nType: `String`  \nDefault: `process.cwd()`\n\n**Example Configuration:**\n```js\nconst argv = require('minimist')(process.argv.slice(2));\nMyApp.launch({\n  cwd: argv.cwd\n}, invoke);\n```\n\n**Matching CLI Invocation:**\n```\nmyapp --cwd ../\n```\n\n#### opts.configPath\n\nDon't search for a config, use the one provided. **Note:** Liftoff will assume the current working directory is the directory containing the config file unless an alternate location is explicitly specified using `cwd`.\n\nType: `String`  \nDefault: `null`\n\n**Example Configuration:**\n```js\nvar argv = require('minimist')(process.argv.slice(2));\nMyApp.launch({\n  configPath: argv.myappfile\n}, invoke);\n```\n\n**Matching CLI Invocation:**\n```\nmyapp --myappfile /var/www/project/Myappfile.js\n```\n\n**Examples using `cwd` and `configPath` together:**\n\nThese are functionally identical:\n```\nmyapp --myappfile /var/www/project/Myappfile.js\nmyapp --cwd /var/www/project\n```\n\nThese can run myapp from a shared directory as though it were located in another project:\n```\nmyapp --myappfile /Users/name/Myappfile.js --cwd /var/www/project1\nmyapp --myappfile /Users/name/Myappfile.js --cwd /var/www/project2\n```\n\n#### opts.preload\n\nA string or array of modules to attempt requiring from the local working directory before invoking the launch callback.\n\nType: `String|Array`  \nDefault: `null`\n\n**Example Configuration:**\n```js\nvar argv = require('minimist')(process.argv.slice(2));\nMyApp.launch({\n  preload: argv.preload\n}, invoke);\n```\n\n**Matching CLI Invocation:**\n```js\nmyapp --preload coffee-script/register\n```\n\n#### callback(env)\n\nA function called after your environment is prepared.  A good place to modify the environment before calling `execute`.  When invoked, `this` will be your instance of Liftoff. The `env` param will contain the following keys:\n\n- `cwd`: the current working directory\n- `preload`: an array of modules that liftoff tried to pre-load\n- `configNameSearch`: the config files searched for\n- `configPath`: the full path to your configuration file (if found)\n- `configBase`: the base directory of your configuration file (if found)\n- `modulePath`: the full path to the local module your project relies on (if found)\n- `modulePackage`: the contents of the local module's package.json (if found)\n- `configFiles`: an object of filepaths for each found config file (filepath values will be null if not found)\n\n### execute(env, [forcedFlags], callback(env, argv))\n\nA function to start your application, based on the `env` given.  Optionally takes an array of `forcedFlags`, which will force a respawn with those node or V8 flags during startup.  Invokes your callback with the environment and command-line arguments (minus node & v8 flags) after the application has been executed.\n\n**Example:**\n\n```js\nconst Liftoff = require('liftoff');\nconst MyApp = new Liftoff({name:'myapp'});\nconst onExecute = function (env, argv) {\n  // Do post-execute things\n  console.log('my environment is:', env);\n  console.log('my cli options are:', argv);\n  console.log('my liftoff config is:', this);\n};\nconst onPrepare = function (env) {\n  var forcedFlags = ['--trace-deprecation'];\n  MyApp.execute(env, forcedFlags, onExecute);\n};\nMyApp.prepare({}, onPrepare);\n```\n\n#### callback(env, argv)\n\nA function called after your application is executed.  When invoked, `this` will be your instance of Liftoff, `argv` will be all command-line arguments (minus node & v8 flags), and `env` will contain the following keys:\n\n- `cwd`: the current working directory\n- `preload`: an array of modules that liftoff tried to pre-load\n- `configNameSearch`: the config files searched for\n- `configPath`: the full path to your configuration file (if found)\n- `configBase`: the base directory of your configuration file (if found)\n- `modulePath`: the full path to the local module your project relies on (if found)\n- `modulePackage`: the contents of the local module's package.json (if found)\n- `configFiles`: an object of filepaths for each found config file (filepath values will be null if not found)\n\n### events\n\n#### `on('preload:before', function(name) {})`\n\nEmitted before a module is pre-load. (But for only a module which is specified by `opts.preload`.)\n\n```js\nvar Hacker = new Liftoff({name:'hacker', preload:'coffee-script'});\nHacker.on('preload:before', function (name) {\n  console.log('Requiring external module: '+name+'...');\n});\n```\n\n#### `on('preload:success', function(name, module) {})`\n\nEmitted when a module has been pre-loaded.\n\n```js\nvar Hacker = new Liftoff({name:'hacker'});\nHacker.on('preload:success', function (name, module) {\n  console.log('Required external module: '+name+'...');\n  // automatically register coffee-script extensions\n  if (name === 'coffee-script') {\n    module.register();\n  }\n});\n```\n\n#### `on('preload:failure', function(name, err) {})`\n\nEmitted when a requested module cannot be preloaded.\n\n```js\nvar Hacker = new Liftoff({name:'hacker'});\nHacker.on('preload:failure', function (name, err) {\n  console.log('Unable to load:', name, err);\n});\n```\n\n#### `on('loader:success, function(name, module) {})`\n\nEmitted when a loader that matches an extension has been loaded.\n\n```js\nvar Hacker = new Liftoff({\n  name: 'hacker',\n  extensions: {\n    '.ts': 'ts-node/register'\n  }\n});\nHacker.on('loader:success', function (name, module) {\n  console.log('Required external module: '+name+'...');\n});\n```\n\n#### `on('loader:failure', function(name, err) {})`\n\nEmitted when no loader for an extension can be loaded. Emits an error for each failed loader.\n\n```js\nvar Hacker = new Liftoff({\n  name: 'hacker',\n  extensions: {\n    '.ts': 'ts-node/register'\n  }\n});\nHacker.on('loader:failure', function (name, err) {\n  console.log('Unable to load:', name, err);\n});\n```\n\n#### `on('respawn', function(flags, child) {})`\n\nEmitted when Liftoff re-spawns your process (when a [`v8flags`](#optsv8flags) is detected).\n\n```js\nvar Hacker = new Liftoff({\n  name: 'hacker',\n  v8flags: ['--harmony']\n});\nHacker.on('respawn', function (flags, child) {\n  console.log('Detected node flags:', flags);\n  console.log('Respawned to PID:', child.pid);\n});\n```\n\nEvent will be triggered for this command:\n`hacker --harmony commmand`\n\n## Examples\n\nCheck out how [gulp](https://github.com/gulpjs/gulp-cli/blob/master/index.js) uses Liftoff.\n\nFor a bare-bones example, try [the hacker project](https://github.com/js-cli/js-hacker/blob/master/bin/hacker.js).\n\nTo try the example, do the following:\n\n1. Install the sample project `hacker` with `npm install -g hacker`.\n2. Make a `Hackerfile.js` with some arbitrary javascript it.\n3. Install hacker next to it with `npm install hacker`.\n3. Run `hacker` while in the same parent folder.\n","time":{"created":"2022-01-26T13:47:30.002Z","modified":"2023-08-08T12:25:33.288Z","3.0.1":"2021-03-12T03:31:17.294Z"},"versions":{"3.0.1":{"name":"liftup","version":"3.0.1","description":"Launch your command line tool with ease.","author":{"name":"Grunt Development Team","url":"https://gruntjs.com/development-team"},"contributors":[],"repository":{"type":"git","url":"git+https://github.com/gruntjs/js-liftup.git"},"license":"MIT","engines":{"node":">=10"},"main":"index.js","scripts":{"pretest":"eslint .","test":"mocha -t 5000 -b -R spec test/index","cover":"nyc --reporter=lcov --reporter=text-summary npm test"},"dependencies":{"extend":"^3.0.2","findup-sync":"^4.0.0","fined":"^1.2.0","flagged-respawn":"^1.0.1","is-plain-object":"^2.0.4","object.map":"^1.0.1","rechoir":"^0.7.0","resolve":"^1.19.0"},"devDependencies":{"chai":"^3.5.0","coffeescript":"^1.10.0","eslint":"^2.13.1","eslint-config-gulp":"^3.0.1","mocha":"^8.3.1","nyc":"^14.1.1","sinon":"~1.17.7"},"keywords":["command line"],"gitHead":"d3d350be57fd1c21d1b973ca2e70c88e78fcb92e","bugs":{"url":"https://github.com/gruntjs/js-liftup/issues"},"homepage":"https://github.com/gruntjs/js-liftup#readme","_id":"liftup@3.0.1","_nodeVersion":"12.18.2","_npmVersion":"6.14.9","dist":{"shasum":"1cb81aff0f368464ed3a5f1a7286372d6b1a60ce","size":10092,"noattachment":false,"tarball":"https://registry.npmmirror.com/liftup/-/liftup-3.0.1.tgz","integrity":"sha512-yRHaiQDizWSzoXk3APcA71eOI/UuhEkNN9DiW2Tt44mhYzX4joFoCZlxsSOF7RyeLlfqzFLQI1ngFq3ggMPhOw=="},"_npmUser":{"name":"vladikoff","email":"vlad@vladikoff.com"},"directories":{},"maintainers":[{"name":"vladikoff","email":"vlad@vladikoff.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/liftup_3.0.1_1615519877116_0.9600375159942789"},"_hasShrinkwrap":false,"publish_time":1615519877294,"_cnpm_publish_time":1615519877294,"_cnpmcore_publish_time":"2021-12-13T12:38:21.823Z"}},"bugs":{"url":"https://github.com/gruntjs/js-liftup/issues"},"contributors":[],"homepage":"https://github.com/gruntjs/js-liftup#readme","keywords":["command line"],"repository":{"type":"git","url":"git+https://github.com/gruntjs/js-liftup.git"},"_source_registry_name":"default"}